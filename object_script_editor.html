<!DOCTYPE html>
<html>
<head>
	<title>Object Script Editor</title>
	<style>
		body {
			background-color: #222;
		}
		.back {
			display: flex;
		}
		.viewbox {
			background-color: #222;
			border: 2px solid #eee;
			height: inherit;
			overflow-y: scroll;
			color: #eee;
		}
		#numeric_editor.viewbox {
			border-left-width: 0px;
		}
		.viewbox-container {
			flex: 1;
			height: 450px;
			padding: 10px;
		}
		.scrollbox {
			padding: 10px;
			padding-left: 20px;
			overflow-y: scroll;
		}
		.map-item {
			padding: 2px;
			transition: 0.5s ease-in-out;
			cursor: pointer;
			color: #eee;
		}
		.map-item:hover, .viewed-index {
			background-color: #555;
		}
		.file-input-container {
			background-color: #222;
			border: 2px solid #eee;
			padding: 10px;
			padding-left: 15px;
			color: #eee;
		}
		.c-highlight {
			background-color: rgba(128,0,0,0.5);
		}
		.error-highlight {
			color: red;
		}
		.line_numbers {
			background-color: #222;
			border: 2px solid #eee;
			height: inherit;
			text-align: right;
			padding-right: 5px;
			color: gainsboro;
			overflow-y: hidden;
		}
		.highlight-c-prompt {
			color: #eee;
		}
		.indent-script-prompt {
			color: #eee;
		}
		button {
			border: 2px solid #eee;
			border-radius: 5px;
			padding: 5px;
			color: #eee;
			background-color: #222;
			transition: 0.25s ease-in-out;
		}
		button.cancel {
			background-color: rgba(81, 1, 1, 0.705);
		}
		button.confirm {
			background-color: rgba(1, 81, 1, 0.705);
		}
		button:hover {
			background-color: #555;
		}
		button.cancel:hover {
			background-color: rgba(160, 1, 1, 0.705);
		}
		button.confirm:hover {
			background-color: rgba(1, 160, 1, 0.705);
		}
		.prompt {
			position:absolute;
			border: 2px solid #eee;
			padding: 10px;
			color: #eee;
			background-color: #222;
			top: 50%;
			left: 50%;
			transform: translate(-50%,-50%);
		}
		.prompt > .head {
			margin: 10px;
			font-weight: bold;
			text-align: center;
			font-size: 2em;
		}
		.prompt > .button-array {
			margin-top: 20px;
			display: flex;
		}
		.prompt > .button-array > .array-item {
			flex: 1;
		}
		.prompt > .button-array > .array-item > button {
			padding: 8px 20px;
		}
		.prompt > .button-array > .array-item.right {
			text-align: right;
		}
		.prompt > input {
			padding: 5px;
		}
		.prompt > .prompt-error {
			text-align: center;
			margin-top: 5px;
			color: red;
			font-size: 1.1em;
		}
		.blocker {
			position:absolute;
			top: 0%;
			left: 0%;
			width: 100%;
			height: 100%;
		}
		.comment-line {
			color: grey;
		}
		.hide {
			display:none;
		}
	</style>
</head>
<body>
	<div class="back">
		<div class="viewbox-container">
			<div style="display:flex;height:100%">
				<div class="line_numbers" style="flex:1" id="numeric_linenums">

				</div>
				<div class="viewbox" id="numeric_editor" style="width:100%;flex:20" onkeyup="liveUpdate()" onscroll="updateScroll()" contenteditable="true" spellcheck="false">

				</div>
			</div>
		</div>
		<div class="viewbox-container">
			<div class="viewbox" id="c_comparison" style="overflow: scroll">

			</div>
		</div>
	</div>
	<div class="back">
		<div class="viewbox-container">
			<div class="file-input-container">
				<strong>Raw Script File:</strong>
				<input type="file" id="file-selector" accept=".raw, .bin"/>
			</div>
			<div class="file-input-container" style="height:200px;margin-top:10px;overflow-y:scroll;" id="error_list"></div>
			<div id="form-controls">
				<div>	
					<button onclick="numericToJSON()">
						Save Script to session
					</button>
					<button onclick="saveArrayToFile()">
						Save map scripts file to PC
					</button>
					<button onclick="initAddItem()">
						Add Script
					</button>
					<button onclick="removeSelectedScript()">
						Remove Selected Script
					</button>
					<button onclick="document.getElementById('import-selector').click()">
						Import Script
					</button>
					<button onclick="exportScript()">
						Export Script
					</button>
					<input type="file" id="import-selector" class="hide" accept=".script"/>
				</div>
				<div class="highlight-c-prompt">
					Highlight associated C Line
					<input type="checkbox" checked="true" id="show_c_highlight_checkbox">
				</div>
				<div class="indent-script-prompt">
					Auto-Indent Script Commands
					<input type="checkbox" checked="true" id="indent_num" onclick="updateLineHovering()">
				</div>
			</div>
		</div>
		<div class="viewbox-container">
			<div class="viewbox scrollbox" id="map-select">

			</div>
		</div>
	</div>
	<div class="blocker hide" id="blocker"></div>
	<div class="new_item prompt hide" id="new-item">
		<div class="head">
			Add Script Item
		</div>
		<label for="new-item-index">New Script ID: 0x</label>
		<input id="new-item-index" type="text" pattern="[a-fA-F0-9]{1,4}" maxlength="4" onkeyup="this.value = filterNewItemInput(this.value)"/>
		<div id="new-item-error" class="prompt-error"></div>
		<div class="button-array">
			<div class="array-item" onclick="togglePromptState('new-item',true)">
				<button class="cancel">Close</button>
			</div>
			<div class="array-item right" onclick="addReferencedScript()">
				<button class="confirm">Confirm</button>
			</div>
		</div>
	</div>
	<script src="script/common_data.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script type="text/javascript">
		function filterNewItemInput(value) {
			document.getElementById("new-item-error").innerText="";
			permitted_chars = ['a','b','c','d','e','f','A','B','C','D','E','F','0','1','2','3','4','5','6','7','8','9']
			return value.split("").filter(item => permitted_chars.includes(item)).join("")
		}
		var file_bytes = []
		var viewed_file = -1;
		const COMMENT_TAG = "//"

		function hex(val) {
			return "0x" + val.toString(16).toUpperCase()
		}

		function str(val) {
			return val.toString()
		}

		function len(arr) {
			return arr.length;
		}

		function updateLineNumbers() {
			var hook = document.getElementById("numeric_editor")
			var num_hook = document.getElementById("numeric_linenums")
			num_hook.innerHTML = "";
			var children = hook.childNodes
			//console.log(indent)
			for (let c = 0; c < children.length; c++) {
				var focused_child = hook.childNodes[c];
				if (focused_child) {
					var num_div = document.createElement("div")
					var num_txt = document.createTextNode((c+1).toString())
					num_div.appendChild(num_txt)
					num_hook.appendChild(num_div)
				}
			}
			updateScroll();
		}

		function updateScroll() {
			document.getElementById("numeric_linenums").scrollTop = document.getElementById("numeric_editor").scrollTop;
		}

		function showCLines(idx) {
			if (document.getElementById("show_c_highlight_checkbox").checked) {
				var rel_c = document.getElementsByClassName("assoc-line-" + idx.toString())
				for (let c = 0; c < rel_c.length; c++) {
					rel_c[c].classList.add("c-highlight")
				}
				var rel_num = document.getElementsByClassName("line" + idx.toString())
				for (let n = 0; n < rel_num.length; n++) {
					rel_num[n].classList.add("c-highlight")
				}
			}
		}

		function clearCLines(idx) {
			var rel_c = document.getElementsByClassName("assoc-line-" + idx.toString())
			for (let c = 0; c < rel_c.length; c++) {
				rel_c[c].classList.remove("c-highlight")
			}
			var rel_num = document.getElementsByClassName("line" + idx.toString())
			for (let n = 0; n < rel_num.length; n++) {
				rel_num[n].classList.remove("c-highlight")
			}
		}

		function updateLineHovering() {
			$(function(){
			    $('div[contentEditable="true"]').each(function(){
			       var text = $(this).clone().children().remove().end().text();// get text
			       var $children = $(this).children();// get children

			       //add text and children again
			       if (text != "") {
			       	$(this).empty().append('<div>'+text+'</div>').append($children);
			       }
			    });
			});
			var hook = document.getElementById("numeric_editor")
			var children = hook.childNodes
			var current_num_indent = 0;
			var indent = document.getElementById("indent_num").checked
			//console.log(indent)
			for (let c = 0; c < children.length; c++) {
				var focused_child = hook.childNodes[c];
				if (focused_child) {
					var pad = current_num_indent * 30;
					if (indent) {
						focused_child.style["padding-left"] = pad.toString() + "px"
					} else {
						focused_child.style["padding-left"] = 0
					}
					if (focused_child.innerText.substring(0,4).toLowerCase() == "cond") {
						current_num_indent++;
					} else if (focused_child.innerText.toLowerCase() == "endblock") {
						current_num_indent = 0;
					}
					focused_child.removeAttribute("class")
					focused_child.classList.add("line" + c.toString())
					focused_child.classList.add("numline")
					focused_child.setAttribute("onmouseover","showCLines(" + c + ")")
					focused_child.setAttribute("onmouseout","clearCLines(" + c + ")")
				}
			}
			updateLineNumbers();
		}

		function convertScriptLine(json) {
			string = "";
			var has_params = false;
			if (json.type == "condition") {
				if (json.func & 0x8000) {
					string += "CONDINV "
				} else {
					string += "COND "
				}
				string += (json.func & 0x7FFF) + " | "
				has_params = true;
			} else if (json.type == "execution") {
				string += "EXEC " + json.func + " | "
				has_params = true;
			} else if (json.type == "endblock") {
				string += "ENDBLOCK"
			}
			
			if (has_params) {
				json.params.forEach((item, index) => {
					string += item
					if (index < 2) {
						string += " "
					}
				})
			}
			if (json.comment) {
				string += (json.comment.length > 0 ? `${json.type == "comment" ? "" : " "}${COMMENT_TAG} ${json.comment}` : "")
			}

			string += "\n"
			return string
		}

		function intToArr(val,size) {
			ret = []
			for (let a = 0; a < size; a++) {
				ret.push(0)
			}
			left = val;
			idx = size - 1;
			while (idx > -1) {
				ret[idx] = left % 256;
				left = (left - ret[idx]) / 256;
				idx -= 1;
				if (idx == -1) {
					break;
				} else if (left == 0) {
					break;
				}
			}
			return ret.slice()
		}

		var new_file = []
		function saveArrayToFile() {
			numericToJSON();
			scripts = scripts.filter(item=>item.id != -1)
			var script_count = scripts.length;
			new_file = [];
			intToArr(script_count,2).forEach(byte => {new_file.push(byte)})
			scripts.forEach(item => {
				script_list = item.script.slice();
				var blocks = [];
				var current_block = [];
				script_list.forEach(item2 => {
					if (item2.type == "condition" || item2.type == "execution") {
						current_block.push(item2)
					} else if (item2.type == "endblock") {
						if (current_block.length > 0) {
							blocks.push(current_block)
						}
						current_block = [];
					}
				})
				var block_count = blocks.length
				intToArr(item.id,2).forEach(byte => {new_file.push(byte)})
				intToArr(block_count,2).forEach(byte => {new_file.push(byte)})
				intToArr(item.behav_9C,2).forEach(byte => {new_file.push(byte)})
				blocks.forEach(block => {
					conditions = block.filter(item2 => item2.type == "condition")
					condition_count = conditions.length;
					intToArr(condition_count,2).forEach(byte => {new_file.push(byte)})
					if (condition_count > 0) {
						conditions.forEach(condition => {
							intToArr(condition.func,2).forEach(byte => {new_file.push(byte)})
							condition.params.forEach(param => {
								intToArr(param,2).forEach(byte => {new_file.push(byte)})
							})
						})
					}
					executions = block.filter(item2 => item2.type == "execution")
					execution_count = executions.length;
					intToArr(execution_count,2).forEach(byte => {new_file.push(byte)})
					if (execution_count > 0) {
						executions.forEach(execution => {
							intToArr(execution.func,2).forEach(byte => {new_file.push(byte)})
							execution.params.forEach(param => {
								intToArr(param,2).forEach(byte => {new_file.push(byte)})
							})
						})
					}
				})
			})
			length = new_file.length;
			to_add = length % 16
			if (to_add > 0) {
				to_add = 16 - to_add
				for (let t = 0; t < to_add; t++) {
					new_file.push(0)
				}
			}
			writeToFile();
			//console.log(new_file)
		}

		function liveUpdate() {
			var text = document.getElementById("numeric_editor").innerText
			var lines = text.split("\n").filter(item => item != "")
			var success = true;
			var can_update = true;
			var errors = []
			var cond_count = 0;
			var exec_count = 0;
			var lines_with_errors = [];
			lines.forEach((line, index) => {
				var pars = line.split(COMMENT_TAG)[0].trim().split(" ")
				if (line.split(COMMENT_TAG)[0].trim().length > 0) {
					var line_idx = (index + 1).toString();
					if (pars[0] == "COND" || pars[0] == "CONDINV") {
						cond_count += 1;
						if (exec_count > 0) {
							success = false;
							can_update = false;
							errors.push("[CRITICAL] Condition occurs after execution before ENDBLOCK on line " + line_idx)
							lines_with_errors.push(index)
						}
					}
					if (pars[0] == "EXEC") {
						exec_count += 1;
					}
					if (pars[0] == "ENDBLOCK") {
						if (exec_count == 0) {
							success = false;
							can_update = true;
							errors.push("Endblock occurs on line " + line_idx + " without an execution, rendering this condition useless")
							lines_with_errors.push(index)
						}
						cond_count = 0;
						exec_count = 0;
					} else {
						var has_nan = isNaN(parseInt(pars[1]));
						if (has_nan) {
							success = false;
							can_update = false;
							errors.push("[CRITICAL] Non-Number function type provided on " + line_idx)
							lines_with_errors.push(index)
						} else {
							if ((pars[1] % 1) != 0) {
								success = false;
								can_update = false;
								errors.push("[CRITICAL] Non-Integer function type provided on " + line_idx)
								lines_with_errors.push(index)
							}
						}
						var has_dec = false;
						for (let a = 0; a < 3; a++) {
							if (isNaN(parseInt(pars[3 + a]))) {
								has_nan = true;
							} else if ((pars[3 + a] % 1) != 0) {
								has_dec = true;
							}
						}
						if (has_nan) {
							success = false;
							can_update = false;
							errors.push("[CRITICAL] One or more non-number parameter(s) provided on " + line_idx)
							lines_with_errors.push(index)
						}
						if (has_dec) {
							success = false;
							can_update = false;
							errors.push("[CRITICAL] One or more non-integer parameter(s) provided on " + line_idx)
							lines_with_errors.push(index)
						}
					}
					if (cond_count > 5) {
						success = false;
						can_update = false;
						errors.push("[CRITICAL] Condition count for a block exceeds 5 on line " + line_idx)
						lines_with_errors.push(index)
					}
					if (exec_count > 4) {
						success = false;
						can_update = false;
						errors.push("[CRITICAL] Execution count for a block exceeds 4 on line " + line_idx)
						lines_with_errors.push(index)
					}
					if (pars.filter(item => item != "").length != 6 && pars[0] != "ENDBLOCK") {
						success = false;
						can_update = false;
						errors.push("[CRITICAL] Invalid length on line " + line_idx)
						lines_with_errors.push(index)
					}
					valid_pars = ["ENDBLOCK","COND","CONDINV","EXEC"]
					if (valid_pars.indexOf(pars[0]) == -1) {
						success = false;
						can_update = false;
						errors.push("[CRITICAL] Invalid line type on line " + line_idx)
						lines_with_errors.push(index)
					}
					if (pars[0] == "ENDBLOCK" && pars.filter(item => item != "").length != 1) {
						errors.push("Endblock on line " + line_idx + " has parameters when it should not")
						lines_with_errors.push(index)
					}
					if (index == (lines.length - 1)) {
						if (pars[0] != "ENDBLOCK") {
							success = false;
							errors.push("[CRITICAL] Trailing conditionals and executions without an endblock on line " + line_idx)
							lines_with_errors.push(index)
						}
					}
					if (pars[0] != "ENDBLOCK" && pars[2] != "|") {
						success = false;
						can_update = true;
						errors.push("Invalid separator on line " + line_idx)
						lines_with_errors.push(index)
					}
				}
			})
			document.getElementById("error_list").innerText = errors.join("\n")
			if (success) {
				document.getElementById("c_comparison").innerHTML = "";
				numericCommandsToC();
				fixTabbing();
			}
			updateLineHovering()
			lines_with_errors.forEach(item => {
				var lwe = document.getElementsByClassName("line" + item)
				for (let l = 0; l < lwe.length; l++) {
					lwe[l].classList.add("error-highlight")
				}
			})
			return success
		}

		function writeToFile() {
			var write_bytes = new Uint8Array(new_file.length);
			new_file.forEach((item,index) => {write_bytes[index] = item})
			var saveByteArray = (function () {
				var a = document.createElement("a");
				document.body.appendChild(a);
				a.style = "display:none";
				return function (data, name) {
					var blob = new Blob(data, {type: "octet/stream"}),
					url = window.URL.createObjectURL(blob);
					a.href = url;
					a.download = name;
					a.click();
					a.remove();
				};
			}())
			saveByteArray([write_bytes],'output.raw')
		}

		function numericToJSON() {
			var success = liveUpdate();
			if (success) {
				var hook = document.getElementById("numeric_editor")
				var text = hook.innerText;
				var lines = text.split("\n").filter(item => item != "").slice()
				var existing_data = scripts.filter(item => item.id == viewed_file)
				var is_new = true;
				var behav = 0;
				if (existing_data.length) {
					is_new = false;
					behav = existing_data[0].behav_9C;
				}
				var new_script_arr = [];
				var cond_count = 0;
				var exec_count = 0;
				var block_arr = [];
				lines.forEach(line => {
					console.log(line.split(" "))
					var numeric_params = line.split(" ")
					var func = 0;
					var params = [];
					if (numeric_params[0] == "EXEC") {
						exec_count += 1;
						func = parseInt(numeric_params[1]);
						params = []
						for (let a = 0; a < 3; a++) {
							params.push(numeric_params[3 + a])
						}
						block_arr.push({
							"type": "execution",
							"func": func,
							"params": params.slice(),
							"comment": line.includes(COMMENT_TAG) ? line.split(COMMENT_TAG)[1].trim() : "",
						})
					} else if (numeric_params[0] == "COND" || numeric_params[0] == "CONDINV") {
						cond_count += 1;
						func = parseInt(numeric_params[1]);
						if (numeric_params[0] == "CONDINV") {
							func += 0x8000
						}
						params = []
						for (let a = 0; a < 3; a++) {
							params.push(numeric_params[3 + a])
						}
						block_arr.push({
							"type": "condition",
							"func": func,
							"params": params.slice(),
							"comment": line.includes(COMMENT_TAG) ? line.split(COMMENT_TAG)[1].trim() : "",
						})
					} else if (numeric_params[0] == "ENDBLOCK") {
						block_arr.push({
							"type": "endblock",
							"comment": line.includes(COMMENT_TAG) ? line.split(COMMENT_TAG)[1].trim() : "",
						})
						if (cond_count <= 5 && exec_count <= 4) {
							block_arr.forEach(block => {
								new_script_arr.push(block)
							})
						}
						block_arr = [];
						cond_count = 0;
						exec_count = 0;
					} else if (numeric_params[0] == COMMENT_TAG) {
						block_arr.push({
							"type": "comment",
							"comment": line.split(COMMENT_TAG)[1].trim()
						})
					}
				})
				var script_insert = {
					"id": viewed_file,
					"behav_9C": behav,
					"script": new_script_arr.slice()
				}
				scripts = scripts.filter(item => item.id != viewed_file)
				scripts.push(script_insert)
			}
		}

		function addScript(new_script_id) {
			script_insert = {
				"id": new_script_id,
				"behav_9C": 0,
				"script": [
					{"type": "condition","func":1,"params":[0,0,0]},
					{"type": "execution","func":1,"params":[1,0,0]},
					{"type": "endblock"},
				]
			}
			scripts.push(script_insert)
		}

		function removeSelectedScript() {
			scripts = scripts.filter(item => item.id != viewed_file)
			populateSelectList(scripts)
		}

		function addReferencedScript() {
			const value = parseInt("0x"+document.getElementById("new-item-index").value,16);
			if (scripts.find(item => item.id == value)) {
				document.getElementById("new-item-error").innerText = "ID already exists";
			} else {
				addScript(value);
				populateSelectList(scripts)
				togglePromptState('new-item',true)
			}
		}

		function importScript(file_data) {
			const script_data = file_data.split("\r\n")
			let found_data = false;
			let found_code = false;
			script_insert = {
				"id": -1,
				"behav_9C": 0,
				"script": []
			}
			script_data.forEach(line => {
				if (line == ".data") {
					found_data = true;
				} else if (line == ".code") {
					found_code = true;
				} else if (found_data && !found_code) {
					prop = line.split(" = ")[0]
					val = line.split(" = ")[1]
					if (val.toLowerCase().includes("0x")) {
						val = parseInt(val.split("0x")[1],16)
					}
					if (prop == "id") {
						script_insert.id = val
					} else if (prop == "behav_9C") {
						script_insert.behav_9C = val
					}
				} else if (found_code) {
					code_data = line.split(" ")
					func = code_data[0]
					has_comment = line.trim().includes(COMMENT_TAG)
					comment = has_comment ? line.split(COMMENT_TAG)[1].trim() : ""
					param_funcs = ["COND","CONDINV","EXEC"]
					if (param_funcs.includes(func.toUpperCase())) {
						param_list = []
						for (let k = 0; k < 3; k++) {
							param_list.push(parseInt(code_data[k+3]))
						}
						if (func.toUpperCase().indexOf("COND") > -1) {
							sub_func = parseInt(code_data[1])
							if (func.toUpperCase() == "CONDINV") {
								sub_func += 0x8000
							}
							script_insert.script.push({"type": "condition","func":sub_func,"params":param_list, "comment": comment})
						} else {
							script_insert.script.push({"type": "execution","func":code_data[1],"params":param_list, "comment": comment})
						}
					} else if (func.toUpperCase() == "ENDBLOCK") {
						script_insert.script.push({"type":"endblock"})
					} else if (has_comment) {
						script_insert.script.push({"type": "comment", "comment": comment})
					}
				}
			})
			console.log(script_insert)
			scripts = scripts.filter(item => item.id != script_insert.id)
			scripts.push(script_insert)
			populateSelectList(scripts)
		}

		function exportScript() {
			numericToJSON();
			export_item = scripts.find(item => item.id == viewed_file)
			if (export_item) {
				text = [
					".data",
					"id = 0x" + (export_item.id).toString(16),
					"behav_9C = " + export_item.behav_9C,
					".code"
				]
				export_item.script.forEach(item => {
					head = ""
					sub_func = -1
					comment = ""
					if (item.type == "condition" && item.func < 0x8000) {
						head = "COND"
						sub_func = item.func
					} else if (item.type == "condition" && item.func >= 0x8000) {
						head = "CONDINV"
						sub_func = item.func - 0x8000
					} else if (item.type == "execution") {
						head = "EXEC"
						sub_func = item.func
					} else if (item.type == "endblock") {
						head = "ENDBLOCK"
					} else if (item.type == "comment") {
						head = COMMENT_TAG
					}
					if (["condition", "execution", "endblock"].includes(item.type)) {
						comment = item.comment.length > 0 ? `${COMMENT_TAG} ${item.comment}` : ""
					}
					if (head != "") {
						if (sub_func == -1 && head == "ENDBLOCK") {
							text.push(head)
						} else {
							if (head == COMMENT_TAG) {
								text.push([head, item.comment].join(" "))
							} else if (head != "ENDBLOCK") {
								text.push([head,sub_func,"|",item.params[0],item.params[1],item.params[2], comment].join(" "))
							}
						}
					}
				})
				console.log(export_item)
				var element = document.createElement("a");
				element.setAttribute("href","data:text/plain;charset=utf-8," + encodeURIComponent(text.join("\r\n")))
				element.setAttribute("download","output.script")
				element.style.display = "none";
				document.body.appendChild(element);
				element.click();
				document.body.removeChild(element);
			}
		}

		function initAddItem() {
			document.getElementById("new-item-index").value = "";
			togglePromptState('new-item',false)
		}

		var current_numeric_line = 0;
		function numericCommandsToC() {
			num_hook = document.getElementById("numeric_editor")
			lines = num_hook.childNodes
			current_numeric_line = 0
			document.getElementById("c_comparison").innerHTML = "";
			//lines = num_hook.innerText.split("\n").filter(item => item != "")
			tab_indentation = 0;
			for (let l = 0; l < lines.length; l++) {
				item = lines[l].innerText;
				if (item) {
					if (item != "") {
						// Filter
						let comment = ""
						if (item.includes(COMMENT_TAG)) {
							comment = item.split(COMMENT_TAG)[1].trim()
						}
						item = item.split(COMMENT_TAG)[0].trim()
						// Process
						index = current_numeric_line;
						line_seg = item.split(" ")
						if (item) {
							if (line_seg[0] != "ENDBLOCK") {
								func = parseInt(line_seg[1])
								params = []
								for (let a = 0; a < 3; a++) {
									params.push(parseInt(line_seg[3 + a]))
								}
								if (line_seg[0] == "EXEC") {
									grabExecution(0, func,params,0,0,"")
								} else {
									if (line_seg[0] == "CONDINV") {
										func += 0x8000
									}
									grabConditional(0, func,params,0,0,"")
								}
							} else {
								var hook = document.getElementById("c_comparison")
								for (let t = 0; t < tab_indentation; t++) {
									local_tab = 0
									for (let a = 0; a < tab_indentation - t - 1; a++) {
										local_tab += 1;
									}
									var block = document.createElement("div")
									var block_text = document.createTextNode("}")
									block.setAttribute("tabbing",local_tab);
									block.classList.add("code-line")
									block.appendChild(block_text)
									hook.appendChild(block)
								}
								tab_indentation = 0;
							}
						}
						if (comment.length > 0) {
							display("comment", `${COMMENT_TAG} ${comment}`, [])
						}
						current_numeric_line++;
					}
				}
			}
		}

		function showScript(script_index, id_index) {
			viewed_file = id_index;
			items = document.getElementsByClassName("map-item")
			for (let i = 0; i < items.length; i++) {
				//console.log(items[i].getAttribute("id-index").toString() + "|" + id_index.toString())
				if (items[i].getAttribute("id-index").toString() == id_index.toString()) {
					items[i].classList.add("viewed-index")
				} else {
					items[i].classList.remove("viewed-index")
				}
			}
			hook = document.getElementById("numeric_editor")
			hook.innerHTML = ""
			var focused_script = scripts.find(item => item.id == id_index)
			if (focused_script) {
				focused_script.script.forEach(item => {
					hook.innerHTML += "<div>" + convertScriptLine(item) + "</div>"
				})
				document.getElementById("c_comparison").innerHTML = "";
				tab_indentation = 0;
				numericCommandsToC()
				fixTabbing()
				liveUpdate();
				updateLineHovering();
			}
		}

		function populateSelectList(script_list) {
			var hook = document.getElementById("map-select")
			hook.innerHTML = "";
			script_list.forEach((item,index) => {
				var item_div = document.createElement("div")
				var item_text = document.createTextNode("0x" + item.id.toString(16).toUpperCase());
				item_div.classList.add("map-item")
				item_div.setAttribute("id-index",item.id.toString())
				item_div.appendChild(item_text)
				item_div.setAttribute("onclick","showScript("+index+"," + item.id.toString() + ")")
				hook.appendChild(item_div)
			})
		}

		document.getElementById("file-selector").addEventListener("change", function() {
			var fr = new FileReader();
			fr.onload = function() {
				var data = fr.result;
				setup_data = fr.result;
			    var array = new Uint8Array(data);
			    file_bytes = array.slice()
				//console.log(file_bytes)
				document.getElementById("form-controls").classList.remove("hide")
			    var script_list = parseFile();
			    populateSelectList(script_list);
			};
			fr.readAsArrayBuffer(document.getElementById("file-selector").files[0]);
        })
		document.getElementById("import-selector").addEventListener("change", function() {
			var fr = new FileReader();
			fr.onload = function() {
				var data = fr.result;
				var enc = new TextDecoder("utf-8");
				var arr = data;
				importScript(enc.decode(arr));
			};
			fr.readAsArrayBuffer(document.getElementById("import-selector").files[0]);
        })		

		function getTriggerTypeName(index) {
			if (index < (len(trigger_types) - 1)) {
				return trigger_types[index]
			}
			return "Type %s" % (hex(index))
		}

		function getSongName(index) {
			if (index < (len(songs) - 1)) {
				return songs[index]
			}
			return "Song %s" % (hex(index))
		}

		function getTOrF(value) {
			if (value == 0) {
				return "False"
			}
			return "True"
		}

		function getSetOrNot(value) {
			if (value == 0) {
				return "Don't Set"
			}
			return "Set"
		}

		var tab_indentation = 0;
		var main_pointer_table_offset = 0x101C50;
		function display(file, str, args) {
			hook = document.getElementById("c_comparison")
			str = str.toString()
			if (args) {
				if (args.length > 0) {
					str_arr = str.split("%s")
					str = ""
					str_arr.forEach((item,index)=> {
						str += str_arr[index]
						if (index < (str_arr.length - 1)) {
							str += args[index]
						}
					})
				}
			}
			if (file != "comment") {
				if (str.substring(str.length - 1) != "{") {
					if (str.substring(str.length - 1) != "}") {
						str += ";"
					}
				}
			}
			line_tabbing = 0
			for (let x = 0; x < tab_indentation; x++) {
				line_tabbing += 1
			}
			if (str.substring(str.length - 1) == "{") {
				tab_indentation += 1;
			} else if (str.substring(str.length - 1) == "}") {
				tab_indentation -= 1;
			}
			var block = document.createElement("div")
			block.classList.add("assoc-line-" + current_numeric_line.toString())
			var block_text = document.createTextNode(str)
			block.setAttribute("tabbing",line_tabbing);
			block.classList.add("code-line")
			if (file == "comment") {
				block.classList.add("comment-line")
			}
			block.appendChild(block_text)
			hook.appendChild(block)
			//hook.innerText += str + "\n"
			//file.write(string + "\n")
		}

		function fixTabbing() {
			var hooks = document.getElementsByClassName("code-line")
			for (let h = 0; h < hooks.length; h++) {
				hooks[h].style["padding-left"] = (parseInt(hooks[h].getAttribute("tabbing")) * 20).toString() + "px"
			}
		}

		function togglePromptState(prompt_id,shown) {
			if (shown) {
				document.getElementById(prompt_id).classList.add("hide")
				document.getElementById("blocker").classList.add("hide")
			} else {
				document.getElementById(prompt_id).classList.remove("hide")
				document.getElementById("blocker").classList.remove("hide")
			}
		}

		function hexToFloat(hx_) {
			return hx_
		}

		conditional_list = [
			{
				"idx": 0,
				"params": ["","",""],
				"details": "Condition always succeeds unless inverse is applied",
			},
			{
				"idx": 1,
				"params": ["Target value","Behaviour offset from 0x48",""],
				"details": "Often used to check function stage if param2 == 0",
			},
			{
				"idx": 2,
				"params": ["","",""],
				"details": "Checks if player is standing on scripted object with locked_to_pad state of 1",
			},
			{
				"idx": 3,
				"params": ["","",""],
				"details": "Returns false",
			},
			{
				"idx": 5,
				"params": ["arg0","arg1",""],
				"details": "Checks output of FUN_806425FC()",
			},
			{
				"idx": 10,
				"params": ["","",""],
				"details": "Checks if player is standing on scripted object with locked_to_pad state of 2",
			},
			{
				"idx": 11,
				"params": ["player->0x12F target","",""],
				"details": "Checks if player is standing on scripted object with locked_to_pad state of 3",
			},
			{
				"idx": 13,
				"params": ["player->0x10E target","",""],
				"details": "Checks if player is standing on scripted object with locked_to_pad state of 1",
			},
			{
				"idx": 23,
				"params": ["player->control_state target","player->control_state_progress target",""],
				"details": "Checks if player ihas a specific control state & progress",
			},
		]

		function grabConditional(param_1, ScriptCommand,params,behaviour,param_3,file) {
			functionType = ScriptCommand & 0x7FFF
			inverseFlag = ScriptCommand & 0x8000
			inverseFlagChar = ""
			inverseFlagInvertedChar = "!"
			if (inverseFlag != 0) {
				inverseFlag = 1;
				inverseFlagChar = "!"
				inverseFlagInvertedChar = ""
			} else {
				inverseFlagChar = ""
				inverseFlagInvertedChar = "!"
			}
			switch(functionType) {
				case 0:
					display(file, "if (%strue) {", [inverseFlagChar])
					break;
				case 1:
					display(file, "if (*(byte *)(behaviour + %s) %s== %s) {", [hex(params[1] + 0x48), inverseFlagChar, str(params[0])])
					break;
				case 2:
					display(file, "x2_successful = 0",[])
					display(file, "x2_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "x2_focusedPlayerNumber_ = x2_focusedPlayerNumber",[])
					display(file, "x2_focusedPlayerNumber = (x2_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[x2_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "x2_focusedPlayerPointer = *(int *)(character_change_pointer[x2_focusedPlayerNumber_)]->character_pointer)",[])
					display(file, "if (*(byte *)(x2_focusedPlayerPointer->locked_to_pad) == 1) {",[])
					display(file, "if (this->id == *(short *)(x2_focusedPlayerPointer->standingOnObjectM2Index)) {",[])
					display(file, "x2_successful = 1",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "} while (x2_focusedPlayerNumber < player_count)",[])
					display(file, "}",[])
					display(file, "if (x2_successful %s== 1) {", [inverseFlagChar])
					break;
				case 3:
					display(file, "if (1 == 0) {",[])
					break;
				case 4:
					display(file, "if (*(ushort *)(behaviour + %s) %s== %s) {", [hex((params[1] * 2) + 0x44), inverseFlagChar, str(params[0])])
					break;
				case 5:
					display(file, "if (FUN_806425FC(%s,%s) %s== 0) {", [str(params[0]), str(params[1]), inverseFlagInvertedChar])
					break;
				case 6:
					display(file, 
						"if (*(code *)(%s)(behaviour,this->id,%s,%s) %s== 0) {", [hex(0x80748048 + (params[0] * 4)), str(params[1]), str(params[2]), inverseFlagInvertedChar])
					break;
				case 7:
					display(file, "if (FUN_80642500(behaviour + 0x14,%s,%s) %s== 0) {", [str(params[0]), str(params[1]), inverseFlagInvertedChar])
					break;
				case 8:
					display(file, "if (*(byte *)(behaviour + 0x51) %s== 0) {", [inverseFlagInvertedChar])
					break;
				case 9:
					display(file, "if (*(byte *)(behaviour + 0x52) %s== 0) {", [inverseFlagInvertedChar])
					break;
				case 10:
					display(file, "xA_successful = 0",[])
					display(file, "xA_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "xA_focusedPlayerNumber_ = xA_focusedPlayerNumber",[])
					display(file, "xA_focusedPlayerNumber = (xA_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[xA_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "xA_focusedPlayerPointer = *(int *)(character_change_pointer[xA_focusedPlayerNumber_]->character_pointer)",[])
					display(file, "xA_successful = 0",[])
					display(file, "if (*(byte *)(xA_focusedPlayerPointer->locked_to_pad) == 2) {",[])
					display(file, "if (this->id == *(short *)(xA_focusedPlayerPointer->standingOnObjectM2Index)) {",[])
					display(file, "xA_successful = 1",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "} while (xA_focusedPlayerNumber < player_count)",[])
					display(file, "}",[])
					display(file, "if (xA_successful %s== 1) {", [inverseFlagChar])
					break;
				case 11:
					display(file, "xB_successful = 0",[])
					display(file, "xB_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "xB_focusedPlayerNumber_ = xB_focusedPlayerNumber",[])
					display(file, "xB_focusedPlayerNumber = (xB_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[xB_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "xB_focusedPlayerPointer = *(int *)(character_change_pointer[xB_focusedPlayerNumber_]->character_pointer)",[])
					display(file, "if (*(byte *)(xB_focusedPlayerPointer->locked_to_pad) == 3) {",[])
					display(file, "if (*(byte *)(xB_focusedPlayerPointer->unk0x12F == %s)) {", [str(params[0])])
					display(file, "if (this->id == *(short *)(xB_focusedPlayerPointer->standingOnObjectM2Index)) {",[])
					display(file, "xB_successful = 1",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "} while (xB_focusedPlayerNumber < player_count)",[])
					display(file, "}",[])
					display(file, "if (xB_successful %s== 1) {", [inverseFlagChar])
					break;
				case 12:
					display(file, "if (%s(((((FLOAT_807F621C == FLOAT_807F61FC) && (FLOAT_807F6220 == 1729.11706543)) && ((FLOAT_807F6224 == 3433.54956055 && ((FLOAT_807F6228 == 330 && (FLOAT_807F622C == 170)))))) && (FLOAT_807F6230 == 0)) && (FLOAT_807F6234 == 1))) {", [inverseFlagInvertedChar])
					break;
				case 13:
					display(file, "xC_successful = 0",[])
					display(file, "xC_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "xC_focusedPlayerNumber_ = xC_focusedPlayerNumber",[])
					display(file, "xC_focusedPlayerNumber = (xC_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[xC_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "xC_focusedPlayerPointer = *(int *)(character_change_pointer[xC_focusedPlayerNumber_]->character_pointer)",[])
					display(file, "if (*(byte *)(xC_focusedPlayerPointer->locked_to_pad) == 1) {",[])
					display(file, "if (this->id == *(short *)(xC_focusedPlayerPointer->standingOnObjectM2Index)) {",[])
					display(file, "if (*(byte *)(xC_focusedPlayerPointer->unk0x10E == %s)) {", [str(params[0])])
					display(file, "xC_successful = 1",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "} while (xC_focusedPlayerNumber < player_count)",[])
					display(file, "}",[])
					display(file, "if (xC_successful %s== 1) {", [inverseFlagChar])
					break;
				case 14:
					display(file, "if (FUN_80641F70(param_1,%s) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 15:
					display(file, "if (FUN_80723C98(*(word *) (behaviour + 0x38)) %s== 0) {", [inverseFlagInvertedChar])
					break;
				case 16:
					x10_conditional = "";
					x10_conditional_2 = "";
					if (params[1] != -1) {
						x10_conditional = "(*(byte *)(behaviour + 0x5C) != " + str(params[1]) + ") || "
					}
					if( params[0] != 0) {
						x10_conditional_2 = "(FUN_8067ACC0(*(ushort *)(behaviour + 0x5E)) & " + str(params[0]) + ")"
						display(file, "if ((((*(byte *)(behaviour + 0x5C) == 0) || %s%s)) || (canHitSwitch() == 0)) {", [x10_conditional, x10_conditional_2])
						display(file, "x10_uvar9 = 0",[])
						display(file, "} else {",[])
						display(file, "FUN_80641724(ObjectModel2ArrayPointer[id2index(this->id)].object_type)",[])
						display(file, "x10_uvar9 = 1",[])
						display(file, "}",[])
						display(file, "if (x10_uvar9 %s== 1) {", [inverseFlagChar])
					} else {
						if (inverseFlag == 1) {
							display(file, "if (true) {",[])
						} else {
							display(file, "if (1 == 0) {",[])
						}
					}
					break;
				case 17:
					display(file, "x11_successful = false",[])
					display(file, "if (loadedActorCount != 0) {",[])
					display(file, "x11_focusedArraySlot = &loadedActorArray",[])
					display(file, "x11_focusedActor = loadedActorArray",[])
					display(file, "while (true) {",[])
					display(file, "x11_focusedArraySlot = x11_focusedArraySlot + 8",[])
					display(file, "if ((*(uint *)(x11_focusedActor->object_properties_bitfield) & 0x2000) == 0) {",[])
					display(file, "if (*(int *)(x11_focusedActor->actor_type) == %s) {", [str(params[0])])
					display(file, "if (x11_focusedActor->locked_to_pad == 1) {",[])
					display(file, "if (this->id == *(short *)(x11_focusedActor->standingOnObjectM2Index)) {",[])
					display(file, "x11_successful = true",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if ((&loadedActorArray + (loadedActorCount * 8) <= x11_focusedArraySlot) || (x11_successful)) break;",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if (%sx11_successful) {", [inverseFlagChar])
					break;
				case 18:
					display(file, "x12_successful = false",[])
					display(file, "if (loadedActorCount != 0) {",[])
					display(file, "x12_focusedArraySlot = &loadedActorArray",[])
					display(file, "x12_focusedActor = loadedActorArray",[])
					display(file, "while (true) {",[])
					display(file, "x12_focusedArraySlot = x12_focusedArraySlot + 8",[])
					display(file, "if ((*(uint *)(x12_focusedActor->object_properties_bitfield) & 0x2000) == 0) {",[])
					display(file, "if (*(int *)(x12_focusedActor->actor_type) == %s) {", [str(params[0])])
					display(file, "if (x12_focusedActor->locked_to_pad == 1) {",[])
					display(file, "if (this->id == *(short *)(x12_focusedActor->standingOnObjectM2Index)) {",[])
					display(file, "if (*(short *)(x12_focusedActor->unk10E) == %s) {", [str(params[1])])
					display(file, "x12_successful = true",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if ((&loadedActorArray + (loadedActorCount * 8) <= x12_focusedArraySlot) || (x12_successful)) break;",[])
					display(file, "x12_focusedActor = *x12_focusedArraySlot",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if (%sx12_successful) {", [inverseFlagChar])
					break;
				case 19:
					display(file, "if (isPlayerWithinDistanceOfObject(%s) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 20:
					display(file, "x14_successful_count = 0",[])
					display(file, "x14_focusedArraySlot = &loadedActorArray",[])
					display(file, "if (loadedActorCount != 0) {",[])
					display(file, "x14_focusedActor = loadedActorArray",[])
					display(file, "while (true) {",[])
					display(file, "x14_focusedArraySlot = x14_focusedArraySlot + 8",[])
					display(file, "if ((*(uint *)(x14_focusedActor->object_properties_bitfield) & 0x2000) == 0) {",[])
					display(file, "if (*(int *)(x14_focusedActor->actor_type) == %s) {", [str(params[0])])
					display(file, "if (x14_focusedActor->locked_to_pad == 1) {",[])
					display(file, "if (this->id == *(short *)(x14_focusedActor->standingOnObjectM2Index)) {",[])
					display(file, "if (*(short *)(x14_focusedActor->unk10E) == %s) {", [str(params[1])])
					display(file, "x14_successful_count = true",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if ((&loadedActorArray + (loadedActorCount * 8) <= x14_focusedArraySlot)) break;",[])
					display(file, "x14_focusedActor = *x14_focusedArraySlot",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if (x14_successful_count %s== %s) {", [inverseFlagChar, str(params[2])])
					break;
				case 21:
					display(file, "if (FUN_80650D04(this->id,%s) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 22:
					display(file, "if ((LevelStateBitfield & %s) != 0) {", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 23:
					display(file, "x17_successful = 0",[])
					display(file, "x17_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "x17_focusedPlayerNumber_ = x17_focusedPlayerNumber",[])
					display(file, "x17_focusedPlayerNumber = (x17_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[x17_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "x17_focusedPlayerPointer = *(int *)(character_change_pointer[x17_focusedPlayerNumber_]->character_pointer)",[])
					display(file, "if (*(byte *)(x17_focusedPlayerPointer->control_state) == %s) {", [str(params[0])])
					if (params[1] == 0) {
						display(file, "x17_successful = 1",[])
					} else {
						display(file, "if (x17_focusedPlayerPointer->control_state_progress == %s) {", [str(params[1])])
						display(file, "x17_successful = 1",[])
						display(file, "}",[])
					}
					display(file, "}",[])
					display(file, "}",[])
					display(file, "} while (x17_focusedPlayerNumber < player_count)",[])
					display(file, "}",[])
					display(file, "if (x17_successful %s== 1) {", [inverseFlagChar])
					break;
				case 24:
					display(file, "x18_successful = 0",[])
					display(file, "if (*(byte *)(behaviour + 0x5C) != 0) {",[])
					if (params[1] != -1) {
						display(file, "if (*(byte *)(behaviour + 0x5C) == %s){", [str(params[1])])
					}
					display(file, "if ((*(ushort *)(behaviour + 0x5E) == %s) && canHitSwitch() != 0) {", [str(params[0])])
					display(file, "FUN_80641724(ObjectModel2Array[id2index(this->id)].object_type)",[])
					display(file, "x18_successful = 1",[])
					display(file, "}",[])
					if (params[1] != -1) {
						display(file, "}",[])
					}
					display(file, "}",[])
					display(file, "if (x18_successful %s== 1) {", [inverseFlagChar])
					break;
				case 25:
					display(file, "if (*(int *)(PlayerPointer->ActorType) %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 26:
					display(file, "if (*(byte *)(character_change_pointer->unk0x2C0) %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 27:
					display(file, "if (*(byte *)(character_change_pointer->unk0x2C1) %s== 0){", [inverseFlagInvertedChar])
					break;
				case 28:
					display(file, "x1C_svar6 = 80650a70(this->id, %s)",[str(params[0])])
					if (params[1] == 0) {
						if (inverseFlag == 0) {
							display(file, "if (x1C_svar6 < %s) {", [str(params[2])])
						} else {
							display(file, "if (x1C_svar6 >= %s) {", [str(params[2])])
						}
					} else if (params[1] == 1) {
						if (inverseFlag == 0) {
							display(file, "if (x1C_svar6 >= %s) {", [str(params[2])])
						} else {
							display(file, "if (x1C_svar6 < %s) {", [str(params[2])])
						}
					} else {
						display(file, "if (1 == 0) {",[])
					}
					break;
				case 29:
					if (params[0] == 0) {
						if (inverseFlag == 0) {
							display(file, "if (*(byte *)(behaviour + %s) < %s) {", [hex(0x48 + params[2]), str(params[1])])
						} else {
							display(file, "if (*(byte *)(behaviour + %s) >= %s) {", [hex(0x48 + params[2]), str(params[1])])
						}
					} else if (params[0] == 1) {
						if (inverseFlag == 0) {
							display(file, "if (*(byte *)(behaviour + %s) >= %s) {", [hex(0x48 + params[2]), str(params[1])])
						} else {
							display(file, "if (*(byte *)(behaviour + %s) < %s) {", [hex(0x48 + params[2]), str(params[1])])
						}
					} else {
						display(file, "if (1 == 0) {",[])
					}
					break;
				case 30:
					display(file, "if ((isEnemySpawnedFromSpawnerTrigger(%s) & 0xFF) %s== 0){", [str(params[0]),inverseFlagInvertedChar])
					break;
				case 31:
					if (inverseFlag == 0) {
						display(file, "if (1 == 0) {",[])
					} else {
						display(file, "if (true) {",[])
					}
					break;
				case 32:
					display(file, "if ((isPlayerWithinDistance(%s) & 0xFF) %s== 0){", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 33:
					display(file, "x21_successful = 0",[])
					display(file, "x21_focusedPlayerNumber = 0",[])
					display(file, "if (player_count != 0) {",[])
					display(file, "do {",[])
					display(file, "x21_focusedPlayerNumber_ = x21_focusedPlayerNumber",[])
					display(file, "x21_focusedPlayerNumber = (x21_focusedPlayerNumber_ + 1) & 0xFF",[])
					display(file, "if (*(byte *)(character_change_pointer[x21_focusedPlayerNumber_]->does_player_exist) != 0) {",[])
					display(file, "x21_focusedPlayerPointer = *(int *)(character_change_pointer[x21_focusedPlayerNumber_]->character_pointer)",[])
					display(file, "if (*(byte *)(x21_focusedPlayerPointer->control_state_progress) == %s) {", [str(params[0])])
					display(file, "x21_successful = 1",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "if (x21_successful %s== 1) {", [inverseFlagChar])
					break;
				case 34:
					display(file, "if (touchingModelTwoById(%s) %s== 0) {", [hex(params[0]), inverseFlagInvertedChar])
					break;
				case 35:
					display(file, "if (CutsceneActive %s== 1) {", [inverseFlagChar])
					break;
				case 36:
					display(file, "x24_focusedActor = getSpawnerTiedActor(%s,0)", [str(params[0])])
					display(file, "if (*(byte *)(x24_focusedActor->control_state) %s== %s) {", [inverseFlagChar, str(params[1])])
					break;
				case 37:					
					display(file, "if (%s(*(byte *)CurrentCollectableBase->SlamLvl => %s)) {", [inverseFlagChar, str(params[0])])
					break;
				case 38:
					display(file, "if ((*(uint *)(PlayerPointer->unk0x368) & %s) %s== 0) {", [hex((params[0] * 0x10000) + params[1]), inverseFlagInvertedChar])
					break;
				case 39:
					display(file, "if ((*(uint *)(PlayerPointer->effectBitfield) & %s) %s== 0) {", [hex((params[0] * 0x10000) + params[1]), inverseFlagInvertedChar])
					break;
				case 40:
					display(file, "if ((*(byte *)(behaviour + 0x9A) & 1) %s== 0) {", [inverseFlagChar])
					break;
				case 41:
					display(file, "if (notTouchingActorSpawnerWithinRan(%s,%s,%s) %s== 0) {", [str(params[0]), str(params[1]), str(params[2]), inverseFlagInvertedChar])
					break;
				case 42:
					if (inverseFlag == 0) {
						display(file, "if (BYTE_807F61F8 != 0 || *(byte *)(PTR_0x807F61F0->control_state) == 5) {",[])
					} else {
						display(file, "if (BYTE_807F61F8 == 0 && *(byte *)(PTR_0x807F61F0->control_state) != 5) {",[])
					}
					break;
				case 43:
					display(file, "if (BYTE_807F61F8 %s== 0) {", [inverseFlagInvertedChar])
					break;
				case 44:
					display(file, "if (FUN_80689BAC(%s) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 45:
					display(file, "if (checkFlag(%s>%s,'Permanent') %s== 0) {", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), inverseFlagInvertedChar])
					break;
				case 46:
					display(file, "if (getAndSetActorSpawnerControlStateFromActorSpawnerID(%s,0,'%s') %s== %s) {", [str(params[0]), getSetOrNot(0), inverseFlagChar, str(params[1])])
					break;
				case 47:
					display(file, "if ((isCharacterSpawnerInState7(%s) & 0xFF) %s== 0) {", [str(params[0] & 0xFF), inverseFlagInvertedChar])
					break;
				case 48:
					display(file, "if (*(byte *)(PlayerPointer->unk0xD1) %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 49:
					display(file, "x31_ivar10_4 = id2index(&WORD_807F6240[%s])", [str(params[0])])
					display(file, "if (ObjectModel2ArrayPointer[x31_ivar10_4]->behaviour_pointer[%s] %s== %s) {", [hex(0x48 + params[2]), inverseFlagChar, str(params[1])])
					break;
				case 50:
					display(file, "if (*(ushort *)PreviousMap %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 51:
					if (params[0] == 0) {
						if (inverseFlag == 0) {
							display(file, "if (%s < getAnimationTimer(PlayerPointer)) {", [str(params[1])])
						} else {
							display(file, "if (%s >= getAnimationTimer(PlayerPointer)) {", [str(params[1])])
						}
					} else if (params[0] == 1) {
						if (inverseFlag == 0) {
							display(file, "if (%s >= getAnimationTimer(PlayerPointer)) {", [str(params[1])])
						} else {
							display(file, "if (%s < getAnimationTimer(PlayerPointer)) {", [str(params[1])])
						}
					} else {
						display(file, "if (1 == 0) {",[])
					}
					break;
				case 52:
					display(file, "x34_uvar4 == FUN_806C8D2C(%s)", [str(params[0])])
					if (inverseFlag == 0) {
						display(file, "if (%s <= &character_collectable_base[(BYTE_807FC929 * 0x5E) + (0x306 * x34_uvar4)] {", [str(params[1])])
					} else {
						display(file, "if (%s > &character_collectable_base[(BYTE_807FC929 * 0x5E) + (0x306 * x34_uvar4)] {", [str(params[1])])
					}
					break;
				case 53:
					display(file, "if (*(byte *)PlayerPointer->0xD0 %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 54:
					display(file, "if (checkFlag(%s>%s,'Temporary') %s== 0) {", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), inverseFlagInvertedChar])
					break;
				case 55:
					display(file, "FUN_80650D8C(this->id,%s,austack30,austack36)", [str(params[0])])
					display(file, "if (austack30[0] %s== %s) {", [inverseFlagChar, str(params[1])])
					break;
				case 56:
					display(file, "if (%s(*(byte *)Character < 5)) {", [inverseFlagChar])
					break;
				case 57:
					display(file, "if ((%s& *(ushort *)PlayerPointer->CollisionQueue->TypeBitfield) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 58:
					display(file, "if (((1 << %s) & BYTE_807F693E) %s== 0) {", [str(params[0]), inverseFlagInvertedChar])
					break;
				case 59:
					display(file, "if (checkFlag(%s>%s,'Global') %s== 0) {", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), inverseFlagInvertedChar])
					break;
				case 60:
					display(file, "if (PlayerPointer->chunk %s== %s) {", [inverseFlagChar, str(params[0])])
					break;
				case 61:
					display(file, "if (BYTE_807F6903 %s== 0) {", [inverseFlagInvertedChar])
					break;
				default:
					display(file, "if ([%s,%s,%s,%s]) {", [str(functionType), str(params[0]), str(params[1]), str(params[2])])
					break;
			}
		}
		function grabExecution(param_1, ScriptCommand,params,behaviour,param_3,file) {
			functionType = ScriptCommand
			switch (functionType) {
				case 0:
					display(file, "FUN_80642748(%s,%s,%s)", [str(params[0]),str(params[1]),str(behaviour)])
					break;
				case 1:
					display(file, "*(byte *)(behaviour + %s) = %s", [hex(params[1] + 0x4B), str(params[0])])
					break;
				case 2:
					display(file, "FUN_80723284(*(int*)(behaviour + 0x38),%s)", [str(params[0])])
					break;
				case 3:
					if (params[0] == 0) {
						display(file, "*(short *)(behaviour + %s) = %s", [hex((params[2] * 2) + 0x44), str(params[1])])
					} else {
						display(file, "*(short *)(behaviour + %s) = *(float *)(behaviour + %s)", [hex((params[2] * 2) + 0x44), hex((params[1] * 4) + 0x14)])
					}
					break;
				case 4:
					display(file, "FUN_80723484(*(int *)(behaviour + 0x38))",[])
					display(file, "FUN_807238D4(*(int *)(behaviour + 0x38),0x807F621C,0x807F6220,0x807F6224)",[])
					break;
				case 5:
					display(file, "FUN_806418E8(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 6:
					display(file, "*(float *)(behaviour + %s) = %s", [hex((params[0] * 4) + 0x14), str(params[1] / 10)])
					break;
				case 7:
					switch(params[0]) {
						case 16:
							display(file, "spawn4Slices()", [])
							break;
						case 68:
							display(file, "controlGiantKoshaTimer(behaviour,this->id,%s)", [str(params[1])])
							break;
						case 104:
							display(file, "showAztecSandstorm(behaviour,this->id",[])
							break;
						case 105:
							display(file, "spawnWrinkly(behaviour,this->id,%s)", [str(params[1])])
							break;
						case 113:
							display(file, "updateMushCannonsProgress(behaviour)", [])
							break;
						case 122:
							display(file, "isNotArcadeRound2()", [])
							break;
						case 124:
							display(file, "doesBLockerStay()", [])
							break;
						case 133:
							display(file, "hasKey()", [])
							break;
						default:
							display(file, "*(code *)(%s)(behaviour,this->id,%s,%s)", [hex(0x80747E70 + (params[0] * 4)), str(params[1]), str(params[2])])
						break;
					}
					break;
				case 8:
					display(file, "FUN_80642844(%s,%s,behaviour)", [str(params[0]), str(params[1])])
					break;
				case 9:
					display(file, "if ((FLOAT_807F621C != FLOAT_807F61FC) || (FLOAT_807F6224 != 3433.54956055)) {",[])
					display(file, "FUN_80642480(%s)", [str(params[0])])
					display(file, "}",[])
					break;
				case 0xA:
					display(file, "*(byte *)(behaviour + 0x50) = %s", [str(params[0])])
					display(file, "*(float *)(behaviour + 0x78) = %s", [str(params[1] / 100)])
					display(file, "*(float *)(behaviour + 0x7C) = %s", [str(params[2] / 100)])
					break;
				case 0xB:
					display(file, "*(short *)(behaviour + 0x80) = %s", [str(params[0])])
					display(file, "*(short *)(behaviour + 0x82) = %s", [str(params[1])])
					break;
				case 0xC:
					display(file, "*(short *)(behaviour + 0x84) = %s", [str(params[0])])
					display(file, "*(short *)(behaviour + 0x86) = %s", [str(params[1])])
					break;
				case 0xD:
					display(file, "*(short *)(behaviour + 0x88) = %s", [str(params[0])])
					display(file, "*(short *)(behaviour + 0x8A) = %s", [str(params[1])])
					break;
				case 0xE:
					display(file, "if (*(short *)(behaviour + %s) < 0) {", [hex(((params[0] & 1) * 2) + 0x10)])
					display(file, "*(short *)(behaviour + %s) = FUN_80605044(this->id,%s,%s,%s)", [hex(((params[0] & 1) * 2) + 0x10), str(params[0]), str(params[2] & 0x7F), str(params[1] & 2)])
					display(file, "}",[])
					break;
				case 0xF:
					xF_ivar5 = params[1]
					if (params[1] < 0) {
						xF_ivar5 = xF_ivar5 + 0x7F
					}
					xF_uvar9 = (xF_ivar5 >> 7) & 0xFF
					xF_bvar15 = xF_uvar9
					xF_ivar5 = params[2]
					if (params[2] < 0) {
						xF_ivar5 = xF_ivar5 + 0x7F
					}
					xF_uvar14 = (xF_ivar5 >> 7) & 0xFF
					if (xF_uvar9 == 0) {
						xF_bvar15 = 0x7F
					}
					if (xF_uvar14 == 0) {
						xF_uvar14 = 0xFF
					}
					display(file, "playSFXFromObject(this->id,%s,%s,%s,%s,%s,0.3)", [str(params[0]), str(xF_uvar14), str(xF_bvar15), str(params[1]&0x7F), str(params[2]&0x7F)])
					break;
				case 0x10:
					display(file, "x10_temp = *(short *)(behaviour + %s)", [hex((params[1] * 2) + 0x10)])
					display(file, "if (-1 < x10_temp) {",[])
					display(file, "FUN_80605380(x10_temp)",[])
					display(file, "*(short *)(behaviour + %s) = 0xFFFF", [hex((params[1] * 2) + 0x10)])
					display(file, "}",[])
					break;
				case 0x11:
					display(file, "FUN_806508B4(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x12:
					display(file, "FUN_8065092C(this->id,%s)", [str(params[0])])
					break;
				case 0x13:
					display(file, "FUN_80650998(this->id,%s)", [str(params[0])])
					break;
				case 0x14:
					display(file, "FUN_80650A04(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x15:
					display(file, "FUN_80650b50(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x16:
					display(file, "FUN_80650BBC(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x17:
					display(file, "FUN_80650C28(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x18:
					display(file, "FUN_80650C98(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x19:
					display(file, "setCharacterChangeParameters(%s,0,0)", [str(params[0])])
					break;
				case 0x1A:
					display(file, "FUN_80650AD8(this->id,%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2] / 100)])
					break;
				case 0x1B:
					display(file, "if ((&WORD_807F6240)[%s] != -1) {", [str(params[0])])
					display(file, "FUN_806335B0((&WORD_807F6240)[%s],1,%s, &CutsceneX, &CutsceneY, &CutsceneZ)", [str(params[0]), str(params[1])])
					display(file, "}",[])
					break;
				case 0x1C:
					display(file, "if ((&WORD_807F6240)[id2index(%s)] != -1) {", [str(params[0])])
					display(file, "x1C_ivar7 = (&WORD_807F6240)[%s]", [str(params[0])])
					display(file, "if ((x1C_ivar7 != -1) && (ObjectModel2ArrayPointer[x1C_ivar7].behaviour != 0)) {",[])
					display(file, "x1C_puvar10 = ObjectModel2ArrayPointer[x1C_ivar7].behaviour + %s", [str(params[1])])
					display(file, "x1C_puvar10[0x48] = x1C_puvar10[0x48] + %s", [str(params[2])])
					display(file, "}",[])
					display(file, "}",[])
					break;
				case 0x1D:
					display(file, "FUN_80642844(%s,%s,behaviour)", [str(params[0]), str(params[1])])
					break;
				case 0x1E:
					display(file, "FUN_80642748(%s,%s,behaviour)", [str(params[0]), str(params[1])])
					break;
				case 0x1F:
					display(file, "FUN_807232EC(*(int *)(behaviour + 0x38),%s)", [str(params[0])])
					break;
				case 0x20:
					display(file, "FUN_80723380(*(int *)(behaviour + 0x38),%s)", [str(params[0])])
					break;
				case 0x21:
					display(file, "FUN_80723320(*(int *)(behaviour + 0x38),%s)", [str(params[0])])
					break;
				case 0x22:
					display(file, "*(int *)(behaviour + 0x38) = FUN_80723020(FLOAT_807F6220,FLOAT_807F6224,%s)", [str(params[2])])
					break;
				case 0x23:
					display(file, "FUN_80723428(*(int *)(behaviour + 0x38))",[])
					display(file, "*(int *)(behaviour + 0x38) = 0xFFFFFFFF",[])
					break;
				case 0x24:
					display(file, "FUN_8072334C(*(int *)(behaviour + 0x38),%s)", [str(params[0])])
					break;
				case 0x25:
					display(file, "playCutsceneFromModelTwoScript(behaviour,%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x26:
					display(file, "setScriptRunState(behaviour,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x27:
					display(file, "FUN_80634EA4(this->id,%s,%s)", [str(params[0]), str(params[1] & 0xFF)])
					break;
				case 0x28:
					display(file, "FUN_80635018(this->id,%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x29:
					display(file, "FUN_8061EF4C(0x29,PlayerPointer->unk0x27C,%s,%s,FLOAT_807F621C)", [str(params[0] & 0xFF), str(params[1])])
					break;
				case 0x2A:
					display(file, "ObjectModel2ArrayPointer[id2Index(this->id)]->unk0x3C = %s", [str(params[0])])
					break;
				case 0x2B:
					display(file, "FUN_80636014(this->id,1)",[])
					break;
				case 0x2C:
					display(file, "FUN_806335B0(this->id,1,%s", [str(params[0])])
					display(file, "FUN_8067A9F0(0,PlayerPointer)",[])
					break;
				case 0x2D:
					display(file, "x2d_counter = 0",[])
					display(file, "x2d_PTR_focusedLoadedActor = &PTR_DAT_807FB930",[])
					display(file, "if (loadedActorCount != 0) {",[])
					display(file, "do {",[])
					display(file, "x2d_ADDR_focusedLoadedActor = *x2d_PTR_focusedLoadedActor",[])
					display(file, "x2d_counter = x2d_counter + 1",[])
					display(file, "if ((*(uint *)(x2d_ADDR_focusedLoadedActor->object_properties_bitfield_1) & 0x2000) == 0) {",[])
					display(file, "if (x2d_ADDR_focusedLoadedActor->locked_to_pad == 0x1) {",[])
					display(file, "if (this->id == *(word *)(x2d_ADDR_focusedLoadedActor->unk0x10C)) {",[])
					if (params[0] == 0) {
						display(file, "*(ushort *)(x2d_ADDR_focusedLoadedActor->unk0x68) = *(ushort *)(x2d_ADDR_focusedLoadedActor->unk0x68) & 0xFFFB",[])
					} else {
						display(file, "*(ushort *)(x2d_ADDR_focusedLoadedActor->unk0x68) = *(ushort *)(x2d_ADDR_focusedLoadedActor->unk0x68) | 4",[])
					}
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "x2d_PTR_focusedLoadedActor = x2d_PTR_focusedLoadedActor + 8",[])
					display(file, "x2d_finishedArray = x2d_counter < loadedActorCount",[])
					display(file, "} while(x2d_finishedArray)",[])
					display(file, "}",[])
					break;
				case 0x2E:
					display(file, "FUN_80651BC0(%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x2F:
					display(file, "FUN_8060B49C(PlayerPointer,%s)", [str(params[0])])
					break;
				case 0x30:
					display(file, "InitMapChange(%s,0)", [str(params[0])])
					break;
				case 0x31:
					if ((params[2] & 0x100) != 0) {
						display(file, "SetIntroStoryPlaying(2)",[])
						display(file, "setNextTransitionType('Fade (Wrong Cutscene)')",[])
					}
					if ((params[2] & 0xFF) == 0) {
						display(file, "InitMapChange_TransferredActor(%s,%s,0,0)", [str(params[0]), str(params[1])])
					} else {
						if ((params[2] & 0xFF) == 1) {
							display(file, "InitMapChange_TransferredActor(%s,%s,0,1)", [str(params[0]), str(params[1])])
						} else if ((params[2] & 0xFF) == 2) {
							display(file, "InitMapChange_TransferredActor(%s,%s,0,3)", [str(params[0]), str(params[1])])
						} else {
							display(file, "InitMapChange_TransferredActor(%s,%s,0,0)", [str(params[0]), str(params[1])])
						}
					}
					break;
				case 0x32:
					display(file, "InitMapChange_ParentMap(%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x33:
					display(file, "FUN_8062B86C(%s,(float)%s,(float)%s)", [str(params[0]), str(params[1]), str(params[2] / 100)])
					break;
				case 0x34:
					display(file, "FUN_8062B8A4(%s,(float)%s,(float)%s)", [str(params[0]), str(params[1]), str(params[2] / 100)])
					break;
				case 0x35:
					display(file, "FUN_80641C98(%s,%s,this->id)", [str(params[0]), str(params[1])])
					break;
				case 0x36:
					display(file, "FUN_80641BCC(%s,%s,this->id)", [str(params[0]), str(params[1])])
					break;
				case 0x37:
					display(file, "FUN_80679200(PlayerPointer,0,0x400000,%s)", [str(params[0] & 0xFF)])
					break;
				case 0x38:
					display(file, "FUN_80651be0(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x39:
					display(file, "*(byte *)(behaviour + 0x4F) = %s", [str(params[0])])
					break;
				case 0x3A:
					display(file, "// Execution Type 0x3A stripped from final. Parameters: %s, %s, %s", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x3B:
					display(file, "*(uint *)(PlayerPointer->unk0x368) = *(uint *)(PlayerPointer->unk0x368) & ~%s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x3C:
					display(file, "if (*(int *)(behaviour + 0x94) != 0) {",[])
					display(file, "deleteActorContainer(*(int *)(behaviour + 0x94))",[])
					display(file, "*(int *)(behaviour + 0x94) = 0",[])
					display(file, "}",[])
					break;
				case 0x3D:
					display(file, "*(byte *)(behaviour + 0x67) = %s", [str(params[0])])
					break;
				case 0x3E:
					display(file, "*(byte *)(behaviour + 0x6F) = %s", [str(params[0])])
					break;
				case 0x3F:
					display(file, "*(byte *)(behaviour + 0x6E) = %s", [str(params[0])])
					break;
				case 0x40:
					display(file, "*(int *)LevelStateBitfield = *(int *)LevelStateBitfield | %s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x41:
					display(file, "WORD_807F6904 = 1",[])
					break;
				case 0x42:
					display(file, "FUN_80634CC8(this->id,%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x43:
					display(file, "if (%s == 1) {", [str(params[0])])
					display(file, "*(int *)(behaviour + 0x8) = *(int *)(behaviour + %s)", [hex((params[1] * 4) + 0x14)])
					display(file, "*(int *)(behaviour + 0xC) = *(int *)(behaviour + %s)", [hex((params[2] * 4) + 0x14)])
					display(file, "}",[])
					display(file, "else {",[])
					display(file, "*(float *)(behaviour + 0x8) = %s", [str(params[1] / 10)])
					display(file, "*(float *)(behaviour + 0xC) = %s", [str(params[2] / 10)])
					display(file, "}",[])
					break;
				case 0x44:
					display(file, "WORD_807F6906 = %s", [str(params[0])])
					display(file, "WORD_807F6908 = %s", [str(params[1])])
					break;
				case 0x45:
					display(file, "*(byte *)(behaviour + 0x60) = %s", [str(params[0])])
					display(file, "*(ushort *)(behaviour + 0x62) = %s", [str(params[1])])
					display(file, "*(byte *)(behaviour + 0x66) = %s", [str(params[2])])
					break;
				case 0x46:
					display(file, "*(byte *)(behaviour + 0x70) = %s", [str(params[0])])
					break;
				case 0x47:
					display(file, "*(byte *)(behaviour + 0x71) = %s", [str(params[0])])
					break;
				case 0x48:
					display(file, "FUN_80604BE8(*(byte *)(behaviour + %s,%s,%s)", [hex((params[0] * 2) + 0x11), str(params[1] / 100), str(params[2])])
					break;
				case 0x49:
					display(file, "createCollision(0,character_change_pointer[0]->character_pointer,%s,%s,%s,CutsceneX,CutsceneY,CutsceneZ)", [str(params[0] & 0xFF),str(params[1]),str(params[2])])
					break;
				case 0x4A:
					display(file, "FUN_8063393C(this->id,1,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x4B:
					display(file, "FUN_8072ED9C(this->id,%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x4C:
					display(file, "x4C_temp = FUN_80650A70()",[])
					display(file, "x4C_temp = (x4C_temp + %s)", [hex(params[1])])
					display(file, "if (x4C_temp < 0) {",[])
					display(file, "x4C_temp = 0",[])
					display(file, "}",[])
					display(file, "FUN_80650A04(this->id,%s,x4C_temp)", [str(params[0])])
					break;
				case 0x4D:
					display(file, "x4D_svar12 = SpawnModelTwoObject(0,%s,FLOAT_807F690C,FLOAT_807F6910,FLOAT_807F6914)", [str(params[0])])
					if (params[1] == 0) {
						display(file, "FUN_80641B00(x4D_svar12,this->id,%s)", [str(params[2])])
					}
					break;
				case 0x4E:
					display(file, "FUN_807146A4(%s)", [str(params[0])])
					display(file, "FUN_807149B8(1)",[])
					display(file, "FUN_80714B84(0)",[])
					break;
				case 0x4F:
					display(file, "if (BYTE_807F6938 != 0x10) {",[])
					if (params[0] == -2) {
						display(file, "(&WORD_807F6918)[BYTE_807F6938] = ObjectModel2ArrayPointer[id2index(this->id)]->id",[])
					} else {
						display(file, "(&WORD_807F6918)[BYTE_807F6938] = %s", [str(params[0])])
					}
					display(file, "BYTE_807F6938 = BYTE_807F6938 + 1",[])
					break;
				case 0x50:
					display(file, "if ((&WORD_807F6240)[%s] != -1) {", [str(params[0])])
					display(file, "FUN_806335B0((&WORD_807F6240)[%s],1,%s)", [str(params[0]), str(params[1])])
					display(file, "}",[])
					break;
				case 0x51:
					display(file, "FUN_806F4F50(this->id,FLOAT_807F621C,FLOAT_807F6220,FLOAT_807F6224)",[])
					break;
				case 0x52:
					display(file, "// Execution Type 0x52 stripped from final. Parameters: %s,%s,%s", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x53:
					display(file, "// Execution Type 0x53 stripped from final. Parameters: %s,%s,%s", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x54:
					display(file, "x54_ivar7 = id2index((&WORD_807F6240)[%s])", [str(params[0])])
					display(file, "if (x54_ivar7 != -1) {",[])
					display(file, "setScriptRunState(ObjectModel2ArrayPointer[x54_ivar7].behaviour,%s,%s)", [str(params[1]), str(params[2])])
					display(file, "}",[])
					break;
				case 0x55:
					display(file, "FUN_8062B630(%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x56:
					display(file, "FUN_80724994(1,%s,0,0)", [str(params[0])])
					break;
				case 0x57:
					display(file, "FUN_80659620(&uStack52,&uStack56,&uStack60,WORD_807F693A)",[])
					display(file, "FUN_80659670(%s + fStack32, %s + fStack56,extraout_a0,extraout_a1, %s + fStack60, WORD_807F693A)", [str(params[0] / 1000), str(params[1] / 1000), str(params[0] / 1000)])
					break;
				case 0x58:
					display(file, "x58_temp = FUN_805FFE50(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					display(file, "if (x58_temp == 0) {",[])
					display(file, "FUN_8063DB3C(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					display(file, "}",[])
					break;
				case 0x59:
					display(file, "FUN_80724994(3,%s,%s,0)", [str(params[0]), str(params[1])])
					break;
				case 0x5A:
					display(file, "*(ushort *)(behaviour + 0x68) = %s", [str(params[0])])
					display(file, "*(ushort *)(behaviour + 0x6A) = %s", [str(params[1])])
					display(file, "*(ushort *)(behaviour + 0x6C) = %s", [str(params[2])])
					break;
				case 0x5B:
					display(file, "FUN_806C92C4(%s)", [str(params[0])])
					break;
				case 0x5C:
					display(file, "FUN_80724A9C(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x5D:
					display(file, "setNextTransitionType(%s)", [str(params[0])])
					break;
				case 0x5E:
					display(file, "FUN_80641874(%s,%s)",[str(params[0]),str(params[1])])
					break;
				case 0x5F:
					display(file, "*(uint *)(PlayerPointer->ExtraInfo->unk0x1F0) = *(uint *)(PlayerPointer->ExtraInfo->unk0x1F0 | %s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x60:
					display(file, "FUN_8065F134()",[])
					break;
				case 0x61:
					if (params[2] == 0) {
						display(file, "playSong('%s', 1)", [getSongName(params[0])])
					} else {
						display(file, "playSong('%s', %s)", [getSongName(params[0]), str(params[2] / 255)])
					}
					break;
				case 0x62:
					display(file, "WORD_807F693A = %s", [str(params[0])])
					break;
				case 0x63:
					display(file, "FUN_8068B830(%s,%s,%s)",[str(params[0]),str(params[1]),str(params[2])])
					break;
				case 0x64:
					display(file, "FUN_8068B8FC()",[])
					break;
				case 0x65:
					display(file, "*(byte *)(behaviour + %s) = (byte *)(behaviour + %s) + %s", [hex(params[1] + 0x4B), hex(params[1] + 0x4B), str(params[0])])
					break;
				case 0x66:
					display(file, "if (BYTE_807F61F8 == 0) {",[])
					display(file, "spawnActor(TimerController)",[])
					display(file, "temp = CurrentActorPointer",[])
					display(file, "WORD_807F61F4 = PTR_PTR_807FBB44",[])
					display(file, "CurrentActorPointer = mainmemory.read_u32_be(0x7FBB44)",[])
					display(file, "spawnTimer(0xDC,0x2A,%s)", [str(params[0])])
					display(file, "BYTE_807F61F8 = 1",[])
					display(file, "WORD_807F61F0 = PTR_PTR_807FBB44",[])
					display(file, "CurrentActorPointer = temp",[])
					display(file, "}",[])
					break;
				case 0x67:
					display(file, "if (BYTE_807F61F8 != 0) {",[])
					display(file, "FUN_806A2B08()",[])
					display(file, "}",[])
					break;
				case 0x68:
					display(file, "if (BYTE_807F61F8 != 0) {",[])
					display(file, "deleteActorContainer(DWORD_807F61F0)",[])
					display(file, "deleteActorContainer(DWORD_807F61F4)",[])
					display(file, "}",[])
					break;
				case 0x69:
					display(file, "setWaterHeight(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2] / 100)])
					break;
				case 0x6A:
					display(file, "increaseWaterHeight(%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2] / 100)])
					break;
				case 0x6B:
					display(file, "setFlag(%s>%s,%s,'Permanent')", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), getTOrF(params[1])])
					break;
				case 0x6C:
					display(file, "FUN_80631B8C(%s)", [str(params[0])])
					break;
				case 0x6D:
					display(file, "FUN_8063A8C4(this->id,1,%s)", [str(params[0] / 100)])
					break;
				case 0x6E:
					display(file, "BYTE_807F693F = %s", [str(params[0])])
					break;
				case 0x6F:
					display(file, "?playMusic(%s,%s)", [str(params[0]), str(params[1] & 0xFF)])
					break;
				case 0x70:
					display(file, "FUN_80602C6C(%s,%s)", [str(params[0]), str(params[1] / 255)])
					break;
				case 0x71:
					display(file, "FUN_80602DC4()",[])
					break;
				case 0x72:
					display(file, "getAndSetActorSpawnerControlStateFromActorSpawnerID(%s,%s,'%s')", [str(params[0]), str(params[1] & 0xFF), getSetOrNot(1)])
					break;
				case 0x73:
					display(file, "FUN_806EB178(0,%s,%s,%s)", [str(params[0]), str(params[1]), str(params[2])])
					break;
				case 0x74:
					// Persistance of code running when not loaded
					display(file, "*(byte *)(behaviour + 0x9B) = *(byte *)(behaviour + 0x9B) | %s", [hex(params[0])])
					break;
				case 0x75:
					display(file, "changeTriggerActiveStateOfFirstInstanceOfType('%s',%s)", [getTriggerTypeName(params[0]), str(params[1])])
					break;
				case 0x76:
					display(file, "x76_counter = 0",[])
					display(file, "x76_focusedLoadedActorSlot = &loadedActorArray",[])
					display(file, "if (loadedActorCount != 0) {",[])
					display(file, "do {",[])
					display(file, "x76_focusedLoadedActor = *x76_focusedLoadedActorSlot",[])
					display(file, "if ((*(uint *)(x76_focusedLoadedActor->object_properties_bitfield) & 0x2000) == 0) {",[])
					display(file, "if (x76_focusedLoadedActor->locked_to_pad == 1) {",[])
					display(file, "if (this->id == *(short *)(x76_focusedLoadedActor->unk0x10c)) {",[])
					display(file, "FUN_80679200(x76_focusedLoadedActor,0,8,0)",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "}",[])
					display(file, "x76_counter = x76_counter + 1",[])
					display(file, "x76_focusedLoadedActorSlot = x76_focusedLoadedActorSlot + 8",[])
					display(file, "} while (x76_counter < loadedActorCount)",[])
					display(file, "}",[])
					break;
				case 0x77:
					display(file, "FUN_80650794(this->id,%s,%s,%s)", [str(params[0]), str(params[1] & 0xFF), str(params[2] / 1000)])
					break;
				case 0x78:
					display(file, "FUN_806335B0(this->id,1,%s)", [str(params[0])])
					display(file, "PlayerPointer->unk0x3A4 = uStack40",[])
					display(file, "PlayerPointer->unk0x3A8 = uStack44",[])
					display(file, "PlayerPointer->unk0x3AC = uStack48",[])
					break;
				case 0x79:
					display(file, "setFlag(%s>%s,%s,'Temporary')", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), getTOrF(params[1])])
					break;
				case 0x7A:
					display(file, "FUN_80661264(%s,%s)", [str(params[0] & 0xFF), str(params[0] & 0xFF)])
					break;
				case 0x7B:
					display(file, "FUN_806335B0(this->id,%s)", [str(params[1])])
					display(file, "FUN_8072ECFC(%s)", [str(params[0])])
					break;
				case 0x7C:
					display(file, "BYTE_80748094 = %s", [str(params[0])])
					break;
				case 0x7D:
					display(file, "if (*(short *)(behaviour + %s) < 0) {", [hex((2 * params[1]) + 0x10)])
					display(file, "*(short *)(behaviour + %s) = FUN_80605044(this->id,%s,%s,%s)", [hex((2 * params[1]) + 0x10), str(params[0]), str(params[2] & 0x7F), str(params[1] & 2)])
					display(file, "}",[])
					break;
				case 0x7E:
					x7e_ivar5 = params[1]
					if (params[1] < 0) {
						x7e_ivar5 = x7e_ivar5 + 0x7F
					}
					x7e_uvar9 = (x7e_ivar5 >> 7) & 0xFF
					x7e_ivar5 = params[2]
					if (params[2] < 0) {
						x7e_ivar5 = x7e_ivar5 + 0x7F
					}
					x7e_uvar14 = (x7e_ivar5 >> 7) & 0xFF
					x7e_bvar15 = x7e_uvar14
					if (x7e_uvar9 == 0) {
						x7e_uvar9 = 0x7F
					}
					if (x7e_uvar14 == 0) {
						x7e_bvar15 = 0xFF
					}
					display(file, "if (BYTE_80748094 < 1) {",[])
					display(file, "playSFX(%s,0x7FFF,0x427C0000,%s)", [str(params[0]), str(x7e_uvar9/127)])
					display(file, "}",[])
					display(file, "else {",[])
					display(file, "FUN_806335B0(this->id,1,BYTE_80748094)",[])
					display(file, "FUN_806086CC(%s,%s,%s,%s,0.3,0)", [str(x7e_bvar15), str(x7e_uvar9), str(params[1] & 0x7F), str(params[2] & 0x7F)])
					display(file, "}",[])
					break;
				case 0x7F:
					if (params[1] == 0) {
						x7f_temp = 0
					} else if (params[1] == 1) {
						x7f_temp = 1
					} else if (params[1] == 2) {
						x7f_temp = 2
					} else if (params[1] == 3) {
						x7f_temp = 3
					} else {
						x7f_temp = 0
					}
					display(file, "FUN_8072EE0C(this->id,%s,%s)", [str(params[0]),str(x7f_temp)])
					break;
				case 0x80:
					display(file, "save()")
					break;
				case 0x81:
					display(file, "BYTE_807F693E = BYTE_807F693E | (1 << %s)", [str(params[0])])
					break;
				case 0x82:
					display(file, "BYTE_807F693E = BYTE_807F693E & ~(1 << %s)", [str(params[0])])
					break;
				case 0x83:
					_item = "Unknown " + hex(params[0])
					if (hud_items.indexOf(params[0]) > -1) {
						_item = hud_items[params[0]]
					}
					display(file, "setHUDItemAsInfinite(%s,%s,%s)", [_item, str(params[1]), getTOrF(params[2])])
					break;
				case 0x84:
					display(file, "setFlag(%s>%s,%s,'Global')", [hex(Math.floor(params[0] / 8)), str(params[0] % 8), getTOrF(params[1])])
					break;
				case 0x85:
					display(file, "FUN_8062D1A8()",[])
					break;
				case 0x86:
					display(file, "FUN_806CF398(PlayerPointer)",[])
					display(file, "InitMapChange_TransferredActor(0x2A,0,%s,2)", [str(params[0])])
					break;
				case 0x87:
					display(file, "warpOutOfBonusGame()",[])
					break;
				case 0x88:
					display(file, "DWORD_807FBB68 = DWORD_807FBB68 | %s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x89:
					display(file, "DWORD_807FBB68 = DWORD_807FBB68 & ~%s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x8A:
					display(file, "FUN_806417BC(%s,%s)", [str(params[0]), str(params[1])])
					break;
				case 0x8B:
					display(file, "*(uint *)(PlayerPointer->unk0x36C) = *(uint *)(PlayerPointer->unk0x36C) & ~%s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x8C:
					display(file, "*(uint *)(PlayerPointer->unk0x36C) = *(uint *)(PlayerPointer->unk0x36C) | %s", [hex((params[0] * 0x10000) + params[1])])
					break;
				case 0x8D:
					display(file, "next_transition_type = 'Fade'",[])
					display(file, "FUN_806CF398(PlayerPointer)",[])
					display(file, "x8d_uvar5 = getWorld(CurrentMap,0)",[])
					display(file, "x8d_ivar6 = isLobby(CurrentMap)",[])
					display(file, "x8d_ivar7 = x8d_uvar5",[])
					display(file, "if (x8d_ivar6 == 0) {",[])
					display(file, "warpOutOfLevel(x8d_ivar7)",[])
					display(file, "}",[])
					display(file, "else {",[])
					display(file, "x8d_svar12 = *(short *)(&DAT_8074809C + (x8d_ivar7 * 2))",[])
					display(file, "x8d_dstack88 = (short)(&WORD_807480AC)[x8d_ivar7]",[])
					display(file, "x8d_uvar9 = isFlagSet(*(short *)(&DAT_807480BC + (x8d_ivar7 * 2)),'Permanent')",[])
					display(file, "if ((x8d_uvar9 == 0) && (x8d_svar12 == 0x57)) {",[])
					display(file, "x8d_dstack88 = 0x15",[])
					display(file, "}",[])
					display(file, "x8d_ivar6 = DetermineLevel_NewLevel()",[])
					display(file, "if (x8d_ivar6 == 0) {",[])
					display(file, "InitMapChange(x8d_svar12,x8d_dstack88)",[])
					display(file, "}",[])
					break;
				case 0x8E:
					display(file, "FUN_8066C904(&ObjectModel2ArrayPointer[id2index(this->id)]->unk0x28)",[])
					break;
				case 0x8F:
					display(file, "FUN_806348B4(&ObjectModel2ArrayPointer[id2index(this->id)]->unk0x48)",[])
					break;
				case 0x90:
					display(file, "BYTE_807F6902 = %s", [str(params[0])])
					break;
				case 0x91:
					display(file, "*(float *)(PlayerPointer->velocity) = %s", [str(params[0])])
					break;
				case 0x92:
					display(file, "*(uint *)(PlayerPointer->unk0x368) = *(uint *)(PlayerPointer->unk0x368) | 0x40000800",[])
					break;
				case 0x93:
					display(file, "FUN_8061F510(%s,%s)", [str(params[0] & 0xFF),str(params[1] & 0xFF)])
					break;
				case 0x94:
					display(file, "FUN_80724994(2,%s,0,0)", [str(params[0])])
					break;
				case 0x95:
					display(file, "WORD_807F693C = 0x80",[])
					break;
				case 0x96:
					display(file, "BYTE_807F6903 = %s", [str(params[0])])
					break;
				default:
					display(file, "[%s,%s,%s,%s]", [str(functionType),str(params[0]), str(params[1]), str(params[2])])
					break;
			}
		}

		function arrToInt(arr) {
			total = 0
			arr.forEach(item=> {
				total = (total * 256) + item
			})
			return total
		}

		function grabAddress(addr) {
			size = 4
			bytes = file_bytes.filter((item,index) => {
				if ((index >= addr) && (index < (addr + size))) {
					return true;
				}
				return false;
			})
			return arrToInt(bytes) + main_pointer_table_offset
		}

		function grab_bytes(start,finish) {
			return file_bytes.filter((item,index) => {
				if ((index >= start) && (index < finish)) {
					return true;
				}
				return false;
			})
		}

		function readData(bytes,size,start) {
			return arrToInt(bytes.filter((item,index) => {
				if ((index >= start) && (index < (start + size))) {
					return true
				}
				return false;
			}))
		}
		var scripts = [];
		function parseFile() {
			viewed_file = -1;
			data = file_bytes.slice()
			read_location = 0;
			script_count = readData(data,2,read_location);
			scripts = [];
			if (script_count > 0) {
				console.log(script_count + " scripts found")
				read_location += 2;
				for (let script_index = 0; script_index < script_count; script_index++) {
					object_id = readData(data,2,read_location);
					console.log(hex(object_id) + ": " + hex(read_location))

					block_count = readData(data,2,read_location + 2);
					behav_9C = readData(data,2,read_location + 4);
					read_location += 6;

					script_lines = [];
					for (let y = 0; y < block_count; y++) {
						conditional_count = readData(data,2,read_location);
						read_location += 2;
						x = {};
						if (conditional_count > 0) {
							for (let z = 0; z <conditional_count; z++) {
								func = readData(data,2,read_location)
								read_location += 2;
								p = []
								for (let a = 0; a < 3; a++) {
									p.push(readData(data,2,read_location))
									read_location += 2;
								}
								script_lines.push({
									"type": "condition",
									"func": func,
									"params": p.slice(),
								})
							}
						}
						execution_count = readData(data,2,read_location);
						read_location += 2;
						if (execution_count > 0) {
							for (let z = 0; z < execution_count; z++) {
								func = readData(data,2,read_location)
								read_location += 2;
								p = []
								for (let a = 0; a < 3; a++) {
									p.push(readData(data,2,read_location))
									read_location += 2;
								}
								script_lines.push({
									"type": "execution",
									"func": func,
									"params": p.slice(),
								})
							}
						}
						script_lines.push({
							"type": "endblock",
						})
					}
					scripts.push({
						"id": object_id,
						"script": script_lines.slice(),
						"behav_9C": behav_9C,
					})
				}
			}
			test = "scripts"
			scripts.sort((a,b) => (a.id > b.id) ? 1 : -1)
			if (test == "length") {
				scripts.sort((a,b) => (a.id > b.id) ? 1 : -1)
				script_str = ""
				for (let s = 0; s < scripts.length; s++) {
					script_str += scripts[s].id + " | " + scripts[s].script.length + "\n"
				}
				console.log(script_str)
			} else if (test == "instructions") {
				script_str = ""
				for (let s = 0; s < scripts.length; s++) {
					if (scripts[s].id == 0xD) {
						for (let l = 0; l < scripts[s].script.length; l++) {
							script_str += JSON.stringify(scripts[s].script[l]) + "\n"
						}
						console.log(script_str)
					}
				}
			} else {
				console.log(scripts)
			}
			return scripts.slice()
		}
	</script>
</body>
</html>