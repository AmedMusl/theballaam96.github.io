<html>
    <head>
        <title>DK64 Randomizer Cosmetic Pack Builder</title>
        <link rel="stylesheet" href="style/nav.css">
		<link rel="stylesheet" href="style/main.css">
        <link rel="stylesheet" href="style/home.css">
        <link rel="stylesheet" href="style/midi-converter.css">
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
		<link rel="manifest" href="/site.webmanifest">
		<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
		<meta name="msapplication-TileColor" content="#da532c">
		<meta name="theme-color" content="#ffffff">
		<meta name="description" content="" />
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
        <style>
            .game-header {
                background-color: rgba(0,0,0,0.8);
                border: 2px solid white;
                border-radius: 5px;
                padding: 5px;
                cursor: pointer;
                transition: 0.5s ease-in-out;
                margin: 5px;
            }
            .game-header:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
            .game-songs {
                background-color: rgba(0,0,0,0.2);
                padding-bottom: 10px;
                padding-left: 10px;
                border-bottom: 1px solid white;
            }
            .panel-sep {
                display: flex;
            }
            .panel-sep-anti {
                display: block;
            }
            .game-handler {
                flex: 1;
                min-width: 50%;
                max-width: 50%;
            }
            .popup_background {
                background-color: rgba(0,0,0,0.5);
                position:fixed;
                top:0;
                left:0;
                width:100%;
                height:100%;
            }
            .popup_prompt {
                background-color: #15172b;
                border-radius: 20px;
                box-sizing: border-box;
                max-height: 70%;
                padding: 20px;
                width: 50%;
                position: relative;
                margin-left: auto;
                margin-right: auto;
                top: 50%;
                transform: translateY(-50%);
                /*text-align: center;*/
                color: white;
                overflow-y: auto;
            }
            .popup_head {
                color: #eee;
                font-family: sans-serif;
                font-size: 36px;
                font-weight: 600;
                margin-top: 30px;
            }
            .popup_subtitle {
                color: #eee;
                font-family: sans-serif;
                font-size: 16px;
                font-weight: 600;
                margin-top: 10px;
            }
            .midi-checkbox-container {
                flex: 1;
                min-width: calc(33% - 10px - 2px - 10px);
                max-width: calc(33% - 10px - 2px - 10px);
                margin: 5px;
            }
            .midi-checkbox {
                border: 1px solid white;
                border-radius: 5px;
                cursor: pointer;
                padding: 5px;
                transition: 0.5s ease-in-out;
                /*width: 100%;*/
                min-height: calc(100% - 12px);
            }
            .midi-checkbox:hover {
                background-color: rgb(255, 255, 255, 0.15);
            }
            .midi-checkbox[ticked="true"] {
                background-color: rgba(255,255,255,0.3);
            }
            .midi-checkbox[ticked="false"] .tick{
                opacity: 0;
            }
            .midi-checkbox .name_data {
                flex: 1;
            }
            .tick {
                height: 1em;
                text-align: right;
                transition: 0.5s ease-in-out;
            }
            .popup_buttons {
                flex: 1;
                margin: 5px;
            }
            .popup_controls {
                margin-bottom: 20px;
            }
            .name_meta_data {
                padding-left: 5px;
            }
            #song_selected_count {
                transition: 0.5s ease-in-out;
                width: fit-content;
            }
            .errored {
                background-color: #b00000;
            }
            #button-panel {
                margin-top: 10px;
            }
            @media only screen and (max-width: 1500px) {
                .popup_prompt {
                    width: 70%;
                }
            }
            @media only screen and (max-width: 1200px) {
                .game-handler {
                    flex: 1;
                    min-width: 100%;
                    max-width: 100%;
                }
            }
            button {
                width: calc(100% - 10px);
                margin: 5px;
            }
            @media only screen and (max-width: 1000px) {
                .popup_prompt {
                    width: 90%;
                }
            }
            @media only screen and (max-width: 800px) {
                .panel-sep {
                    display: block;
                }
                .panel-sep-anti {
                    display: flex;
                }
                .sep-left {
                    border-right: none;
                }
            }
            @media only screen and (max-width: 750px) {
                .midi-checkbox-container {
                    min-width: calc(50% - 10px - 2px - 10px);
                    max-width: calc(50% - 10px - 2px - 10px);
                }
            }
            @media only screen and (max-width: 500px) {
                .midi-checkbox-container {
                    min-width: calc(100% - 10px - 2px - 10px);
                    max-width: calc(100% - 10px - 2px - 10px);
                }
            }
            input[type=text] {
                background-color: #303245;
                border-radius: 5px;
                border: 0;
                box-sizing: border-box;
                color: #eee;
                font-size: 18px;
                height: 100%;
                outline: 0;
                padding: 7px 20px;
                width: -webkit-fill-available;
                width: -moz-fill-available;
                /*width: fill-available;*/
                margin: 5px;
            }
            #song_selected_count {
                padding: 5px;
                margin-left: auto;
                margin-right: auto;
            }
            .audio_container {
                margin-left: auto;
                text-align: right;
                width: calc(2.5em - 5px);
                height: 50%;
            }
            .audio_controller {
                width: calc(2.5em - 5px);
                height: calc(2.5em - 5px);
                background-color: #15172b;
                position: absolute;
                transform: translate(calc(7px - (2 * (5px + 1px))), calc(0px - 2.5em));
                border-top: 1px solid white;
                border-left: 1px solid white;
                border-top-left-radius: 5px;
                padding-left: 5px;
                padding-top: 5px;
            }
            .audio_interaction {
                border-radius: 5px;
                border: 1px solid white;
                height: -webkit-fill-available;
                height: -moz-fill-available;
                /*height: fill-available;*/
                vertical-align: middle;
                line-height: calc(2.5em - 5px - 2px);
                text-align: center;
                cursor: pointer;
                transition: 0.5s ease-in-out;
            }
            .audio_interaction:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
            .audio-close-container {
                text-align: right;
            }
            .audio-close {
                width: fit-content;
                margin-left: auto;
                padding: 5px;
                transition: 0.5s ease-in-out;
                border-radius: 5px;
            }
            .audio-close:hover {
                background-color: rgba(255, 255, 255, 0.4);
            }
            .fixed-body {
                overflow-y: clip;
            }
            .load_bar {
                height: 10px;
            }
            #loading_bar {
                margin-top: 20px;
            }
            #loading_left{
                background-color: #7c80a3;
            }
            #loading_right{
                background-color: #20254f;
            }
        </style>
    </head>
    <body>
        <nav id="navigation"></nav>
        <div class="v_spacer">

		</div>
        <div class="flexsplitter">
            <div class="homebox">
                <div class="header master_header">
                    <strong>DK64 Randomizer Pack Builder</strong>
                </div>
            </div>
        </div>
        <div class="flexsplitter">
            <div class="homebox" style="color:white">
                <div class="panel-sep">
                    <div class="sep sep-left">
                        <input style="flex:3; height:auto" type="text" placeholder="&#x1F50D; Search Game..." id="search-game" onkeyup="filterGame(this.value)"/>
                        <button style="flex:1" id="select-all-songs" onclick="selectAllSongs()">Select All Songs</button>
                        <div class="panel-sep-anti" id="button-panel" style="flex:2">
                            <button style="flex:1" onclick="uploadPack()">Upload Pack</button>
                            <input type="file" class="hide" accept=".zip" id="uploaded_pack" />
                            <button style="flex:1" onclick="buildPack()">Build Pack</button>
                        </div>
                        <button style="flex:1" onclick="getShareLink()">Get Shareable Link</button>
                        <div id="song_selected_count">0 songs selected</div>
                    </div>
                    <div class="sep" style="flex:2">
                        <div id="song_list" class="flexsplitter" style="flex-wrap:wrap"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="popup_background hide" id="popup">
            <div class="popup_prompt">
                <div class="popup_head" id="prompt_head">Add songs to pack</div>
                <div>
                    Hide Credits:
                    <input type="checkbox" id="credits_hidden" onclick="handleCredits()"/>
                </div>
                <div id="popup_controls"></div>
                <hr>
                <div class="flexsplitter">
                    <button class="popup_buttons" onclick="hidePopup()">Cancel</button>
                    <button class="popup_buttons" onclick="destroyPopup()">Apply</button>
                    <button class="popup_buttons" id="game-select-toggle" onclick="selectMaster()">Select All</button>
                </div>
            </div>
        </div>
        <div class="popup_background hide" id="audio-event">
            <div class="popup_prompt" style="width:fit-content">
                <div class="audio-close-container">
                    <div class="audio-close noselect" onclick="closeSong()">Close</div>
                </div>
                <div id="audio-event-content">
                    <audio controls>
                        <source src="https://cdn.discordapp.com/attachments/1097234540373745854/1106055293495943168/BK_Grunty_Fight.mp3" type="audio/mpeg">
                    </audio>
                </div>
            </div>
        </div>
        <div class="popup_background" id="load-event">
            <div class="popup_prompt">
                <div class="popup_head">Loading Site Data</div>
                <div id="loading_bar" class="flexsplitter load_bar">
                    <div id="loading_left" class="load_bar" style="flex:0"></div>
                    <div id="loading_right" class="load_bar" style="flex:100"></div>
                </div>
                <div id="loading_text"></div>
            </div>
        </div>
        <script src="script/nav.js"></script>
        <script>          
            const ZELDA_NAME = "The Legend of Zelda: "
            let midi_data_copy = null;
            let total_data_copy = null;
            let current_game = null;
            let uploaded_pack_data = {};
            let api_key = "AIzaSyA9CnqJmq2lf-jC_WwcXyXfyoqa6Bs7HC0"
            let api_key_check_ran = false;
            const MISC_NAME = "Other"
            fetch("DRIVE_API_KEY", {cache: "no-store"})
                .then(async (response) => {
                    if (response.ok) {
                        const new_key = await response.text()
                        api_key = new_key;
                    }
                    api_key_check_ran = true;
                })
            

            function last(array) {
                return array[array.length - 1];
            }

            function uuidv4() {
                return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                  (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                );
              }

            function getCellValue(reference, index) {
                const val = reference.c[index].v.replaceAll("|","");
                if ((val == null) || (val == undefined)) {
                    return null;
                }
                if (val.trim() == "") {
                    return null;
                }
                return val.trim()
            }

            class MIDIHeader {
                constructor (construction_index, mandatory) {
                    this.construction_index = construction_index
                    this.mandatory = mandatory
                }
            }

            class OldMIDIInfo {
                constructor (drive_id, audio, converter, timestamp) {
                    this.converter = converter;
                    this.drive_id = drive_id;
                    this.audio = audio;
                    this.timestamp = timestamp;
                }
            }

            class MIDIInfo {
                constructor (name, game, group, composer, converter, drive_id, timestamp, audio, index) {
                    this.name = name;
                    this.game = game;
                    this.group = group;
                    this.composer = composer;
                    this.converter = converter;
                    this.drive_id = drive_id;
                    this.timestamp = timestamp;
                    this.audio = audio;
                    this.index = index;
                    this.days_since_submission = null;
                    this.is_new = false;
                    this.older_revisions = null;
                    if (timestamp != null) {
                        const current_dt = new Date();
                        const timestamp_dt = new Date(timestamp);
                        const diff_dt = current_dt - timestamp_dt;
                        this.days_since_submission = Math.floor(diff_dt / (1000 * 60 * 60 * 24));
                        this.is_new = this.days_since_submission < 7;
                    }
                }

                update_entry(replacement) {
                    if (this.older_revisions == null) {
                        this.older_revisions = [];
                    }
                    this.older_revisions.push(new OldMIDIInfo(
                        this.drive_id,
                        this.audio,
                        this.converter,
                        this.timestamp,
                    ))
                    let converter_list = this.converter.split(",").map(item => item.trim());
                    replacement.converter.split(",").map(item => item.trim()).forEach(item => {
                        if (!converter_list.includes(item)) {
                            converter_list.push(item);
                        }
                    })
                    this.converter = converter_list.join(", ");
                    this.drive_id = replacement.drive_id;
                    this.audio = replacement.audio ? replacement.audio : this.audio;
                    this.timestamp = replacement.timestamp;
                    this.days_since_submission = replacement.days_since_submission;
                    this.is_new = replacement.is_new;
                }
            }
            
            let pack_zip_data = null;

            function clone(instance) {
                return Object.assign(
                    Object.create(
                        // Set the prototype of the new object to the prototype of the instance.
                        // Used to allow new object behave like class instance.
                        Object.getPrototypeOf(instance),
                    ),
                    // Prevent shallow copies of nested structures like arrays, etc
                    JSON.parse(JSON.stringify(instance)),
                );
              }

            async function getSpreadsheetData() {
                const spreadsheetId = "13WWHcGiYJQD_rUqfGL17Lp0zn7MveU5xf7Fy-CNghzo"
                const sheetId = "0"
                const tab_name = "Song Uploads"
                const res = await fetch(`https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:json&tq&gid=0`)
                const text = await res.text()
                json = JSON.parse(text.substr(47).slice(0, -2))
                let counter = 0;
                midi_data_copy = [];
                total_data_copy = [];
                let used_game_song_combos = [];
                for (let i = 1; i < json.table.rows.length; i++) {
                    const ref = json.table.rows[i];
                    const headers = [
                        new MIDIHeader(6, false), // Timestamp
                        new MIDIHeader(1, true), // Game
                        new MIDIHeader(0, true), // Name
                        new MIDIHeader(2, true), // Folder/Group
                        new MIDIHeader(3, false), // Composer
                        new MIDIHeader(4, false), // Converter
                        new MIDIHeader(5, true), // Drive ID
                        new MIDIHeader(7, false), // Audio
                    ]
                    let params = new Array(headers.length).fill(null);
                    let permit = true;
                    headers.forEach((header, index) => {
                        const value = getCellValue(ref, index);
                        if ((value == null) && (header.mandatory)) {
                            permit = false;
                        }
                        params[header.construction_index] = value;
                    })
                    if (permit) {
                        const new_data = new MIDIInfo(...params, counter)
                        const game_song_combo = `${new_data.game}|${new_data.name}`
                        total_data_copy.push(clone(new_data))
                        if (!used_game_song_combos.includes(game_song_combo)) {
                            // Completely new song
                            midi_data_copy.push(new_data)
                            used_game_song_combos.push(game_song_combo)
                        } else {
                            // Used song, update existing entry
                            const existing_entry = midi_data_copy.find(item => ((item.game == new_data.game) && (item.name == new_data.name)));
                            if (existing_entry) {
                                existing_entry.update_entry(new_data)
                            }
                        }
                        counter++
                    }
                }
            }

            const site_is_down = false;
            const total_prog = 5;
            async function getMidiData() {
                let prog = 0;
                updateProgress(prog++, total_prog, "Initializing");
                await waitFor(_ => api_key_check_ran);
                updateProgress(prog++, total_prog, "Loaded API Key");
                await getSpreadsheetData()
                updateProgress(prog++, total_prog, "Grabbed midi data");
                const spreadsheetId = "13WWHcGiYJQD_rUqfGL17Lp0zn7MveU5xf7Fy-CNghzo"
                const pack_sheet_id = "1917417042"
				const pack_res = await fetch(`https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:json&tq&gid=${pack_sheet_id}`, {cache: "no-store"})
				const pack_res_text = await pack_res.text()
                const pack_json = JSON.parse(pack_res_text.substr(47).slice(0, -2))
                const zip_id = pack_json.table.rows[0].c[0].v;
                let ban = false;
                if (zip_id == null) {
                    ban = true;
                } else if (zip_id.trim().length == 0) {
                    ban = true;
                }
                if (ban) {
                    throw new Error("No pack.zip ID loaded. This is likely due to a song upload occurring.")
                    return;
                }
                const zip_url = getDriveDownload(zip_id);
                const zip_res = await fetch(zip_url);
                pack_zip_data = await zip_res.blob();
                updateProgress(prog++, total_prog, "Grabbing Pack.zip");
                const hook = document.getElementById("song_list")
                let html = ""
                let songs_by_game = {}
                let other = []
                midi_data_copy.forEach(song => {
                    const game_name = song.game;
                    if (game_name == MISC_NAME) {
                        other.push(song)
                    } else {
                        if (!Object.keys(songs_by_game).includes(game_name)) {
                            songs_by_game[game_name] = []
                        }
                        songs_by_game[game_name].push(song)
                    }
                })
                songs_by_game = Object.keys(songs_by_game).sort().reduce(
                    (obj, key) => { 
                        obj[key] = songs_by_game[key]; 
                        return obj;
                    }, {}
                );
                songs_by_game[MISC_NAME] = other.slice();
                const char_upper_alpha_idx = Array.from(Array(26)).map((e, i) => i + 65);
                const char_lower_alpha_idx = Array.from(Array(26)).map((e, i) => i + 97);
                const char_upper_alpha = char_upper_alpha_idx.map((x) => String.fromCharCode(x));
                const char_lower_alpha = char_lower_alpha_idx.map((x) => String.fromCharCode(x));
                const char_num = Array.from(Array(10).keys()).map(x => x.toString())
                const char_alphanumeric = char_upper_alpha + char_lower_alpha + char_num;
                Object.keys(songs_by_game).forEach(game_pretty => {
                    let game = game_pretty.split("").filter(item => char_alphanumeric.includes(item)).join("").toLowerCase();
                    if (game != null) {
                        const song_list = songs_by_game[game_pretty].sort()
                        // <input type='checkbox' class='midi-checkbox' id='' onclick='updateMaster(\"${game}\")' game='${game}'/>
                        let local_html = {};
                        song_list.forEach(song => {
                            const group = song.group;
                            let displayed_song_name = song.name;
                            let composer = song.composer ? song.composer : "";
                            let converter = song.converter ? song.converter : "";
                            let audio = song.audio;
                            if (!Object.keys(local_html).includes(group)) {
                                local_html[group] = "";
                            }
                            const state_index = song.index;
                            local_html[group] += 
                                `
                                <div class='midi-checkbox-container'>
                                    <div 
                                        class='midi-checkbox noselect' 
                                        song-id='${song.index}' 
                                        onclick='updateTickbox(this,\"${game}\")' 
                                        ticked=${parseSeed(state_index) ? 'true' : 'false'} 
                                        game='${game}'>
                                        <div class='flexsplitter'>
                                            <div class='name_data'>
                                                <strong>${displayed_song_name.replace('.bin','')}</strong>
                                                <div class='name_meta_data${isCreditHidden() ? ' hide' : ''}'>
                                                    ${composer != '' ? `<div title='Composer${composer.includes(',') ? 's' : ''} of original song: ${composer}'>&#9834; ${composer}</div>` : ''}
                                                    ${converter != '' ? `<div title='Converter${converter.includes(',') ? 's' : ''} into DK64 Soundfont: ${converter}'>&#127898; ${converter}</div>` : ''}
                                                </div>
                                            </div>
                                            <img class="tick" src='./assets/tick.svg'>
                                        </div>
                                    </div>
                                    ${
                                        audio != null ?
                                        `<div class='audio_container${isCreditHidden() ? ' hide' : ''}'>
                                            <div class='audio_controller'>
                                                <div class='audio_interaction' onclick='playSong(\"${audio}\",\"${converter}\")'>&#9654;</div>
                                            </div>
                                        </div>` : ''
                                    }
                                </div>`
                        })
                        let local_html_total = "";
                        const group_priority = {
                            "bgm": "Background Music",
                            "events": "Events",
                            "majoritems": "Major Items",
                            "minoritems": "Minor Items"
                        }
                        let first = true;
                        Object.keys(group_priority).forEach(group => {
                            if (Object.keys(local_html).includes(group)) {
                                local_html_total += `${first ? '' : '<br>'}
                                    <div class='popup_subtitle'>${group_priority[group]}</div>
                                    <div class='flexsplitter' style='flex-wrap:wrap'>
                                        ${local_html[group]}
                                    </div>
                                `
                                first = false;
                            }
                        })
                        const game_name = game_pretty;
                        html += `<div class='game-handler'>
                            <div class='game-header noselect collapsed' onclick='toggleGameVisibility(\"${game}\",this)'>${game_name}</div>
                            <div class='game-songs hide' game='${game}'>
                                ${local_html_total}
                            </div>
                        </div>`
                    }
                })
                hook.innerHTML = html;
                updateProgress(prog++, total_prog, "Populated Site");
                updateMaster();
                updateProgress(prog++, total_prog, "Updated Master");
            }
            
            if ((!site_is_down) || (window.location.origin.includes("localhost"))) {
                getMidiData();
            } else {
                updateProgress(0, 1, "Site is down for Maintainence. Please check back later")
            }

            function convertSongName(game, song) {
                return `${game}|${song.replaceAll(" ", "_").replaceAll(".bin","")}`
            }

            function getDriveDownload(drive_id) {
                return `https://www.googleapis.com/drive/v3/files/${drive_id}?alt=media&key=${api_key}`
            }

            function idToSongInfo(id) {
                if (midi_data_copy != null) {
                    let song = null;
                    let folder = null;
                    let download = null;
                    let song_index = null;
                    let drive_id = null;
                    let game = null;
                    const entry = midi_data_copy.find(item => item.index == id);
                    if (entry) {
                        song = entry.name;
                        folder = entry.group;
                        download = getDriveDownload(entry.drive_id);
                        song_index = id;
                        drive_id = entry.drive_id
                        game = entry.game;
                    }
                    if (song != null) {
                        return {
                            "song": song,
                            "game": game,
                            "folder": folder,
                            "download": download,
                            "index": song_index,
                            "drive_id": drive_id
                        }
                    }
                }
                return null;
            }
            function hidePopup() {
                document.getElementById("popup").classList.add("hide");
                document.getElementById("popup_controls").innerHTML = "";
                updateCount()
                document.body.classList.remove("fixed-body")
            }

            function destroyPopup() {
                const song_el = document.getElementsByClassName("game-songs");
                for (let s = 0; s < song_el.length; s++) {
                    if (song_el[s].getAttribute("game") == current_game) {
                        let songs_set = {};
                        const inputs = document.getElementById("popup_controls").getElementsByClassName("midi-checkbox");
                        for (let i = 0; i < inputs.length; i++) {
                            songs_set[inputs[i].getAttribute("song-id")] = inputs[i].getAttribute("ticked");
                        }
                        const new_inputs = song_el[s].getElementsByClassName("midi-checkbox");
                        for (let n = 0; n < new_inputs.length; n++) {
                            new_inputs[n].setAttribute("ticked", songs_set[new_inputs[n].getAttribute("song-id")]);
                        }
                        hidePopup();
                        return;
                    }
                }
                hidePopup()
            }

            function toggleGameVisibility(game_internal, el) {
                const game_pretty = el.innerText;
                document.body.classList.add("fixed-body")
                document.getElementById("popup").classList.remove("hide")
                const song_el = document.getElementsByClassName("game-songs");
                document.getElementById("prompt_head").innerText = game_pretty;
                for (let s = 0; s < song_el.length; s++) {
                    if (song_el[s].getAttribute("game") == game_internal) {
                        document.getElementById("popup_controls").innerHTML = song_el[s].innerHTML;
                        let songs_set = {};
                        const inputs = song_el[s].getElementsByClassName("midi-checkbox");
                        for (let i = 0; i < inputs.length; i++) {
                            songs_set[inputs[i].getAttribute("song-id")] = inputs[i].getAttribute("ticked");
                        }
                        const new_inputs = document.getElementById("popup_controls").getElementsByClassName("midi-checkbox");
                        for (let n = 0; n < new_inputs.length; n++) {
                            new_inputs[n].setAttribute("ticked", songs_set[new_inputs[n].getAttribute("song-id")]);
                        }
                        updateMaster();
                        handleCredits();
                        current_game = game_internal;
                        return;
                    }
                }
            }

            let folder_data = {}
            let build_progress = 0;
            let build_limit = 0;

            function updateProgress(progress, total, text="") {
                document.getElementById("loading_left").style.flex = progress.toString()
                document.getElementById("loading_right").style.flex = (total - progress).toString()
                document.getElementById("loading_text").innerText = text;
                if (progress == total) {
                    document.getElementById("load-event").classList.add("hide")
                }
            }

            function filterFilename(unsafe_filename) {
                const bad_characters = "#%&{}<>*?$!'\":@+`|=".split("");
                const split_filename = unsafe_filename.split("")
                return split_filename.filter(item => !bad_characters.includes(item)).join("")
            }

            async function buildPack() {
                if ((getSongSelectedCount() < 1) && (Object.keys(uploaded_pack_data).length == 0)) {
                    document.getElementById("song_selected_count").classList.add("errored");
                    setTimeout(() => {
                        document.getElementById("song_selected_count").classList.remove("errored");
                    }, 2000);
                    return;
                }
                if (pack_zip_data == null) {
                    return;
                }
                const checkboxes = document.getElementsByClassName("midi-checkbox");
                folder_data = {...uploaded_pack_data}
                let data_array = []
                for (let c = 0; c < checkboxes.length; c++) {
                    if (checkboxes[c].getAttribute("ticked") == "true") {
                        const data = idToSongInfo(checkboxes[c].getAttribute("song-id"));
                        if (data != null) {
                            data_array.push(data)
                        }
                    }
                }
                const zip_full = new JSZip();
                pack_zip_jszip = await zip_full.loadAsync(pack_zip_data);
                for (let [filename_0, file_0] of Object.entries(pack_zip_jszip.files)) {
                    if (!file_0.dir) {
                        const found_data = data_array.find(item => item.drive_id == filename_0.replace(".bin",""));
                        if (found_data) {
                            const fileData = await pack_zip_jszip.files[filename_0].async("blob");
                            if (!Object.keys(folder_data).includes(found_data.folder)) {
                                folder_data[found_data.folder] = []
                            }
                            folder_data[found_data.folder].push({
                                "song": found_data.song,
                                "game": found_data.game,
                                "data": fileData
                            })
                        }
                    }
                }
                const zip = new JSZip();
                Object.keys(folder_data).forEach(folder => {
                    const files  = folder_data[folder];
                    const f_zip = zip.folder(folder)
                    files.forEach(file => {
                        f_zip.file(filterFilename(`${file.game} ${file.song}.bin`), file.data)
                    })
                })

                zip.generateAsync({type:"blob"}).then(function(content) {
                    saveAs(content, "pack.zip");
                });
            }

            function selectMaster() {
                const checkboxes = document.getElementById("popup_controls").getElementsByClassName("midi-checkbox");
                let all_checked = true;
                let all_unchecked = true;
                for (let c = 0; c < checkboxes.length; c++) {
                    if (checkboxes[c].getAttribute("ticked") == "true") {
                        all_unchecked = false;
                    } else {
                        all_checked = false;
                    }
                }
                let setting = true;
                if (all_checked) {
                    setting = false;
                }
                for (let c = 0; c < checkboxes.length; c++) {
                    checkboxes[c].setAttribute("ticked", setting.toString());
                }
                updateMaster();
            }

            function updateMaster() {
                const checkboxes = document.getElementById("popup_controls").getElementsByClassName("midi-checkbox");
                let all_checked = true;
                let all_unchecked = true;
                for (let c = 0; c < checkboxes.length; c++) {
                    if (checkboxes[c].getAttribute("ticked") == "true") {
                        all_unchecked = false;
                    } else {
                        all_checked = false;
                    }
                }
                let text = "Select All";
                if (all_checked) {
                    text = "Deselect All";
                }
                document.getElementById("game-select-toggle").innerText = text;
                const all_checkboxes = document.getElementsByClassName("midi-checkbox");
                all_checked = true;
                all_unchecked = true;
                for (c = 0; c < all_checkboxes.length; c++) {
                    if (all_checkboxes[c].getAttribute("ticked") == "true") {
                        all_unchecked = false;
                    } else {
                        all_checked = false;
                    }
                }
                text = "Select All Songs";
                if (all_checked) {
                    text = "Deselect All Songs";
                }
                document.getElementById("select-all-songs").innerText = text;
                updateCount();
            }

            function filterGame(text) {
                const force_enable = text.replace(" ","").length == 0;
                const handlers = document.getElementsByClassName("game-handler")
                for (let h = 0; h < handlers.length; h++) {
                    const game_name = handlers[h].getElementsByClassName("game-header")[0].innerText.toLowerCase();
                    if (force_enable || game_name.includes(text.toLowerCase())) {
                        handlers[h].classList.remove("hide");
                    } else {
                        handlers[h].classList.add("hide");
                    }
                }
            }

            function updateTickbox(el, game) {
                if (el.getAttribute("ticked") == "false") {
                    el.setAttribute("ticked",true);
                } else {
                    el.setAttribute("ticked",false);
                }
                updateMaster();
            }

            function getSongSelectedCount() {
                let count = 0;
                const checkboxes = document.getElementsByClassName("midi-checkbox");
                for (let c = 0; c < checkboxes.length; c++) {
                    if (checkboxes[c].getAttribute("ticked") == "true") {
                        count += 1;
                    }
                }
                const bad_checkboxes = document.getElementById("popup_controls").getElementsByClassName("midi-checkbox");
                for (let c = 0; c < bad_checkboxes.length; c++) {
                    if (bad_checkboxes[c].getAttribute("ticked") == "true") {
                        count -= 1;
                    }
                }
                return count;
            }

            function updateCount() {
                const count = getSongSelectedCount();
                let song_text = "songs"
                if (count == 1) {
                    song_text = "song";
                }
                document.getElementById("song_selected_count").innerText = `${count} ${song_text} selected.`
            }

            function isCreditHidden() {
                return document.getElementById("credits_hidden").checked;
            }

            function getUpdatedVersion(drive_id) {
                let found_id = null;
                midi_data_copy.forEach(item => {
                    if (item.older_revisions != null) {
                        if (item.older_revisions.map(a => a.drive_id).includes(drive_id)) {
                            found_id = item.drive_id;
                        }
                    }
                })
                return found_id;
            }

            function handleCredits() {
                const credit_info = document.getElementById("popup").getElementsByClassName("name_meta_data");
                const audio_containers = document.getElementById("popup").getElementsByClassName("audio_container");
                const hide = document.getElementById("credits_hidden").checked;
                for (let c = 0; c < credit_info.length; c++) {
                    if (hide) {
                        credit_info[c].classList.add("hide");
                    } else {
                        credit_info[c].classList.remove("hide");
                    }
                }
                for (let a = 0; a < audio_containers.length; a++) {
                    if (hide) {
                        audio_containers[a].classList.add("hide");
                    } else {
                        audio_containers[a].classList.remove("hide");
                    }
                }
            }

            function selectAllSongs() {
                const checkboxes = document.getElementsByClassName("midi-checkbox");
                let all_checked = true;
                for (let c = 0; c < checkboxes.length; c++) {
                    if (checkboxes[c].getAttribute("ticked") == "false") {
                        all_checked = false;
                    }
                }
                let state = "true"
                if (all_checked) {
                    state = "false";
                }
                for (let c = 0; c < checkboxes.length; c++) {
                    checkboxes[c].setAttribute("ticked",state);
                }
                updateMaster();
            }

            document.getElementById("uploaded_pack").addEventListener("change", function(e) {
                var fr = new FileReader();
                fr.onload = function() {
                    handlePack(fr.result);
                };
                fr.readAsArrayBuffer(document.getElementById("uploaded_pack").files[0]);
            })

            function waitFor(conditionFunction) {
                const poll = resolve => {
                    if(conditionFunction()) resolve();
                    else setTimeout(_ => poll(resolve), 400);
                }
                return new Promise(poll);
            }

            function checkArrayMatch(array_a, array_b) {
                if (array_a.length != array_b.length) {
                    return false; // Mismatching array size
                }
                for (let a = 0; a < array_a.length; a++) {
                    if (array_a[a] != array_b[a]) {
                        return false; // Byte mismatch
                    }
                }
                return true;
            }

            async function handlePack(data) {
                // Load all data
                let site_data = {};
                uploaded_pack_data = {};
                let req = new Array(midi_data_copy.length).fill(null);
                let loaded_count = 0;
                const zip_full = new JSZip();
                pack_zip_jszip = await zip_full.loadAsync(pack_zip_data);
                for (let [filename_0, file_0] of Object.entries(pack_zip_jszip.files)) {
                    if (!file_0.dir) {
                        const filename_id = filename_0.replace(".bin","")
                        const song = total_data_copy.find(item => item.drive_id == filename_id)
                        loaded_count++;
                        if (song) {
                            const fileData = await pack_zip_jszip.files[filename_0].async("Uint8Array");
                            site_data[`${song.drive_id}.bin`] = {
                                "group": song.group,
                                "data": Array.from(fileData),
                                "selected_version": song.drive_id,
                                "updated_version": getUpdatedVersion(song.drive_id) ? getUpdatedVersion(song.drive_id) : song.drive_id,
                            }
                        }
                    }
                }
                console.log(site_data)
                const new_zip = new JSZip();
                let site_song_data = {};
                let compressed_data = {}
                const zip_data = await new_zip.loadAsync(data);
                for (let [filename_0, file_0] of Object.entries(zip_data.files)) {
                    if (!file_0.dir) {
                        const fileData = await zip_data.files[filename_0].async("Uint8Array");
                        const file_path_array = filename_0.split("/")
                        const file_group = file_path_array[file_path_array.length - 2];
                        compressed_data[filename_0] = {
                            "group": file_group,
                            "data": Array.from(fileData)
                        };
                    }
                }
                await waitFor(_ => loaded_count >= midi_data_copy.length);

                // Parse data for matching arrays
                let matching_songs = [];
                Object.keys(compressed_data).forEach(song_a => {
                    if (last(song_a.split("/")).toLowerCase() != "predule.bin") { // Temporarily installed to weed out the bad bin
                        const found_song = Object.keys(site_data).find(item => {
                            return checkArrayMatch(compressed_data[song_a].data, site_data[item].data)
                        })
                        if (found_song) {
                            const new_song = site_data[found_song].updated_version;
                            if (!matching_songs.includes(new_song)) {
                                matching_songs.push(new_song)
                            }
                        } else {
                            // Song isn't on site. TODO: Handle persisting these songs
                            const item_name = last(song_a.split("/"));
                            const item_group = compressed_data[song_a].group;
                            const item_data = compressed_data[song_a].data;
                            if (!Object.keys(uploaded_pack_data).includes(item_group)) {
                                uploaded_pack_data[item_group] = []
                            }
                            uploaded_pack_data[item_group].push({
                                "song": item_name,
                                "data": new Blob([new Uint8Array(item_data)])
                            })
                        }
                    }
                })
                const checkboxes = document.getElementsByClassName("midi-checkbox")
                for (let c = 0; c < checkboxes.length; c++) {
                    checkboxes[c].setAttribute("ticked", "false");
                }
                matching_songs.forEach(m_drive_id => {
                    const entry = midi_data_copy.find(item => item.drive_id == m_drive_id.replace(".bin",""))
                    if (entry) {
                        const game = entry.game;
                        const id = entry.index;
                        for (c = 0; c < checkboxes.length; c++) {
                            if (checkboxes[c].getAttribute("song-id") == id) {
                                checkboxes[c].setAttribute("ticked", "true");
                            }
                        }
                    }
                })
                updateMaster();
            }

            function uploadPack() {
                document.getElementById("uploaded_pack").click();
            }

            function playSong(url, converter) {
                const hook = document.getElementById("audio-event-content");
                if (url.includes("cdn.discordapp.com")) {
                    // Embedded audio
                    hook.innerHTML = `
                        <audio controls autoplay>
                            <source src="${url}" type="audio/mpeg">
                        </audio>
                    `
                } else if ((url.includes("youtube")) || (url.includes("youtu.be"))) {
                    const CONVERTER_NO_EXTERNAL = []; // Any users who make their videos non-distributable on external websites will just open a new tab to YT
                    if (CONVERTER_NO_EXTERNAL.includes(converter)) {
                        window.open(url, "_blank")
                        return;
                    }
                    // Embedded YT Link
                    let video_id = null;
                    if (url.includes("youtube")) {
                        // Full YT Link
                        const queryString = `?${url.split("?")[1]}`;
                        const urlParams = new URLSearchParams(queryString);
                        video_id = urlParams.get("v")
                    } else if (url.includes("youtu.be")) {
                        // YT URL Shortener
                        video_id = last(url.split("/"))
                    }
                    if (video_id != null) {
                        hook.innerHTML = `
                            <iframe 
                                width="560"
                                height="315"
                                src="https://www.youtube.com/embed/${video_id}"
                                title="YouTube video player"
                                frameborder="0"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                                allowfullscreen
                                ></iframe>
                        `
                    }

                } else {
                    window.open(url, "_blank")
                    return;
                }
                document.getElementById("audio-event").classList.remove("hide")
            }

            function closeSong() {
                document.getElementById("audio-event-content").innerHTML = ""
                document.getElementById("audio-event").classList.add("hide")
            }

            function getShareLink() {
                const seed = convertSelectionsToString();
                const stateObj = {s: seed};
                let url = new URL(window.location.href);
                url.searchParams.set("s",seed.toString());
                window.history.replaceState(stateObj, "", url.toString());
            }
            const B64_chars = [
                "A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q",
                "R","S","T","U","V","W","X","Y","Z",
                "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q",
                "r","s","t","u","v","w","x","y","z",
                "$","?","_",".","!","*","'","@",";",",",
                "~",":"
            ];
            const nums = ["0","1","2","3","4","5","6","7","8","9"];
            const BIT_SIZE_PER_CHAR = 6;

            function convertSelectionsToString() {
                let activated = [];
                const checkboxes = document.getElementsByClassName("midi-checkbox")
                for (let c = 0; c < checkboxes.length; c++) {
                    const index = idToSongInfo(checkboxes[c].getAttribute("song-id")).index;
                    if (activated.length <= index) {
                        const diff = (index - activated.length) + 1;
                        for (let d = 0; d < diff; d++) {
                            activated.push(false)
                        }
                    }
                    activated[index] = checkboxes[c].getAttribute("ticked") == "true"
                }
                const B64_SIZE = Math.ceil(activated.length / BIT_SIZE_PER_CHAR);
                let base64num = new Array(B64_SIZE).fill(0)
                activated.forEach((bit, index) => {
                    if (bit) {
                        base64num[Math.floor(index / BIT_SIZE_PER_CHAR)] |= (1 << (index % BIT_SIZE_PER_CHAR))
                    }
                })
                let b64_string = "";
                let prev_char = "";
                let counter = 0;
                let char_seq = []
                base64num.forEach((character, index) => {
                    if ((index == 0) || char_seq[char_seq.length - 1][0] != B64_chars[character]) {
                        char_seq.push([])
                    }
                    char_seq[char_seq.length - 1].push(B64_chars[character])
                })
                char_seq.forEach(subset => {
                    if (subset.length > 1) {
                        b64_string += subset.length.toString()
                    }
                    b64_string += subset[0];
                })
                return b64_string;
            }

            function unpackSeed(seed) {
                const characters = seed.split("");
                let count_string = "";
                let unpacked_seed_nums = [];
                characters.forEach(char => {
                    if (nums.includes(char)) {
                        count_string += char;
                    } else {
                        let count = 1;
                        if (count_string != "") {
                            count = Number(count_string);
                        }
                        if (B64_chars.includes(char)) {
                            for (let c = 0; c < count; c++) {
                                unpacked_seed_nums.push(B64_chars.indexOf(char));
                            }
                        }
                        count_string = "";
                    }
                })
                return unpacked_seed_nums.slice()
            }

            function parseSeed(index) {
                const queryString = window.location.search;
                const urlParams = new URLSearchParams(queryString);
                const seed = urlParams.get("s")
                if (seed == null) {
                    return false; // No data
                }
                const seed_arr = unpackSeed(seed);
                const loc = Math.floor(index / BIT_SIZE_PER_CHAR);
                const subposition = index % BIT_SIZE_PER_CHAR;
                if (loc >= seed_arr.length) {
                    return false; // Data is past seed boundaries
                }
                return (seed_arr[loc] & (1 << subposition)) != 0; // Extracted from seed
            }
        </script>
    </body>
</html>