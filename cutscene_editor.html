<!DOCTYPE html>
<html>
<head>
	<title>Cutscene Editor</title>
	<style>
		body {
			background-color: #222;
		}
		.back {
			display: flex;
		}
		.viewbox {
			background-color: #222;
			border: 2px solid #eee;
			height: inherit;
			overflow-y: scroll;
			color: #eee;
		}
		#numeric_editor.viewbox {
			border-left-width: 0px;
		}
		.viewbox-container {
			flex: 1;
			height: 450px;
			padding: 10px;
		}
		.scrollbox {
			padding: 10px;
			padding-left: 20px;
			overflow-y: scroll;
		}
		.map-item {
			padding: 2px;
			transition: 0.5s ease-in-out;
			cursor: pointer;
			color: #eee;
		}
		.map-item:hover, .viewed-index {
			background-color: #555;
		}
		.file-input-container {
			background-color: #222;
			border: 2px solid #eee;
			padding: 10px;
			padding-left: 15px;
			color: #eee;
		}
		.c-highlight {
			background-color: rgba(128,0,0,0.5);
		}
		.error-highlight {
			color: red;
		}
		.line_numbers {
			background-color: #222;
			border: 2px solid #eee;
			height: inherit;
			text-align: right;
			padding-right: 5px;
			color: gainsboro;
			overflow-y: hidden;
		}
		.show-cutscene-numbers {
			color: #eee;
		}
		.indent-script-prompt {
			color: #eee;
		}
		button {
			border: 2px solid #eee;
			border-radius: 5px;
			padding: 5px;
			color: #eee;
			background-color: #222;
			transition: 0.25s ease-in-out;
		}
		button.cancel {
			background-color: rgba(81, 1, 1, 0.705);
		}
		button.confirm {
			background-color: rgba(1, 81, 1, 0.705);
		}
		button:hover {
			background-color: #555;
		}
		button.cancel:hover {
			background-color: rgba(160, 1, 1, 0.705);
		}
		button.confirm:hover {
			background-color: rgba(1, 160, 1, 0.705);
		}
		.prompt {
			position:absolute;
			border: 2px solid #eee;
			padding: 10px;
			color: #eee;
			background-color: #222;
			top: 50%;
			left: 50%;
			transform: translate(-50%,-50%);
		}
		.prompt > .head {
			margin: 10px;
			font-weight: bold;
			text-align: center;
			font-size: 2em;
		}
		.preview-head {
			margin: 5px;
			margin-top: 10px;
			font-weight: bold;
			text-align: center;
			font-size: 1.5em;
			margin-left: auto;
			margin-right: auto;
		}
		.prompt > .button-array {
			margin-top: 20px;
			display: flex;
		}
		.prompt > .button-array > .array-item {
			flex: 1;
		}
		.prompt > .button-array > .array-item > button {
			padding: 8px 20px;
		}
		.prompt > .button-array > .array-item.right {
			text-align: right;
		}
		.prompt > input {
			padding: 5px;
		}
		.prompt > .prompt-error {
			text-align: center;
			margin-top: 5px;
			color: red;
			font-size: 1.1em;
		}
		.blocker {
			position:absolute;
			top: 0%;
			left: 0%;
			width: 100%;
			height: 100%;
		}
		.hide {
			display:none;
		}
		.code_item {
			padding: 10px;
			border: 1px solid white;
		}
		.code_duration {
			font-weight: bold;
			padding-bottom: 6px;
		}
		.code_sample {
			padding-left: 15px;
		}
		.flex-container {
			display: flex;
		}
		.flex-item {
			flex: 1;
		}
		.code-item-edit {
			background-color: goldenrod;
			font-size: 1.3em;
		}
		.code-item-edit:hover {
			background-color: darkgoldenrod;
		}
		.code-item-add {
			background-color: green;
			width: 100%;
		}
		.code-item-add:hover {
			background-color: darkgreen;
		}
		.code-item-remove {
			background-color: firebrick;
			font-size: 1.5em;
		}
		.code-item-remove:hover {
			background-color: darkred;
		}
		select, input {
			padding: 5px;
		}
		.code {
			font-family: monospace;
			background-color: black;
			padding: 5px;
		}
		.point-button-add {
			background-color: green;
		}
		.point-button-remove {
			background-color: firebrick;
		}
		.point-button-add:hover {
			background-color: darkgreen;
		}
		.point-button-remove:hover {
			background-color: darkred;
		}
		.map-item-empty {
			color: red;
		}
	</style>
</head>
<body>
	<div class="back">
		<div class="viewbox-container">

		</div>
		<div class="viewbox-container">
			<div class="viewbox" id="cutscene_script_display" style="overflow-x: hidden">

			</div>
		</div>
	</div>
	<div class="back">
		<div class="viewbox-container" style="height: 300px">
			<div class="file-input-container">
				<strong>Raw Cutscene File:</strong>
				<input type="file" id="file-selector" accept=".bin"/>
			</div>
			<div class="file-input-container" style="height:200px;margin-top:10px;overflow-y:scroll;" id="error_list"></div>
			<div id="form-controls" class="hide">
				<div>	
					<!-- <button onclick="numericToJSON()">
						Save Script to session
					</button> -->
					<button onclick="saveCutscenesToFile(true, false)">
						Save to PC
					</button>
					<button onclick="purgeUnusedItems()">
						Purge Unused Items
					</button>
					<button onclick="addCutscene()">
						Add Cutscene
					</button>
					<button onclick="emptyCutscene()">
						Empty Selected Cutscene
					</button>
					<button onclick="removeCutscene()">
						Remove Last Cutscene
					</button>
					<!-- <button onclick="initAddItem()">
						Add Script
					</button>
					<button onclick="removeSelectedScript()">
						Remove Selected Script
					</button>
					<button onclick="document.getElementById('import-selector').click()">
						Import Script
					</button>
					<button onclick="exportScript()">
						Export Script
					</button> -->
					<input type="file" id="import-selector" class="hide" accept=".script"/>
				</div>
				<div class="show-cutscene-numbers">
					Show Cutscene Numbers (Names)
					<input type="checkbox" checked="true" id="show_cs_numbers_checkbox" onclick="updateCutsceneNames()">
				</div>
			</div>
		</div>
		<div class="viewbox-container" style="height: 300px">
			<strong style="color:white">Populate Names:</strong> <select id="map-selection" onchange="updateCutsceneNames();"></select>
			<div class="viewbox scrollbox" id="map-select">

			</div>
		</div>
	</div>
	<div class="blocker hide" id="blocker"></div>
	<div class="new_item prompt hide" id="new-item">
		<div class="head">
			Add Script Item
		</div>
		<label for="new-item-index">New Script ID: 0x</label>
		<input id="new-item-index" type="text" pattern="[a-fA-F0-9]{1,4}" maxlength="4" onkeyup="this.value = filterNewItemInput(this.value)"/>
		<div id="new-item-error" class="prompt-error"></div>
		<div class="button-array">
			<div class="array-item" onclick="togglePromptState('new-item',true)">
				<button class="cancel">Close</button>
			</div>
			<div class="array-item right" onclick="addReferencedScript()">
				<button class="confirm">Confirm</button>
			</div>
		</div>
	</div>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="script/common_data.js"></script>
	<script type="text/javascript">
		function populateMapList() {
			var hook = document.getElementById("map-selection")
			const map_copy = maps.map((item, index) => {
				return {
					"name": item,
					"index": index,
				}
			}).sort((a, b) => (a.name > b.name) ? 1 : -1)
			hook.innerHTML = `
				${map_copy.map((item, index) => `
					${(index == 0 ? "<option value='-1'>------------</option>" : "")}
					<option value="${item.index}">${item.name}</option>	
				`)}
			`
		}
		populateMapList();
		function updateCutsceneNames() {
			index = document.getElementById("map-selection").value
			if (index != "") {
				index = parseInt(index)
				if (index > -1) {
					items = document.getElementsByClassName("map-item")
					for (let i = 0; i < items.length; i++) {
						let name = "";
						const cutscene_index = items[i].getAttribute("id-index");
						if (Object.keys(cutscene_names).includes(index.toString())) {
							map_cutscene_names = cutscene_names[index.toString()]
							if (Object.keys(map_cutscene_names).includes(cutscene_index.toString())) {
								name = map_cutscene_names[cutscene_index.toString()]
							}
						}
						if (name == "") {
							name = `Cutscene ${cutscene_index}`
						}
						if (document.getElementById("show_cs_numbers_checkbox").checked) {
							name = `[${cutscene_index}] ${name}`;
						}
						items[i].innerText = name;
					}
				}
			}
		}

		function updateEmptyScripts() {
			var items = document.getElementsByClassName("map-item")
			for (let i = 0; i < items.length; i++) {
				const target_index = items[i].getAttribute("id-index");
				const data = cutscene_data["cutscenes"].find(item => item.index == target_index);
				if (data) {
					if (data.point_sequence.length == 0) {
						items[i].classList.add("map-item-empty")
					} else {
						items[i].classList.remove("map-item-empty")
					}
				}
			}
		}


		function filterNewItemInput(value) {
			document.getElementById("new-item-error").innerText="";
			permitted_chars = ['a','b','c','d','e','f','A','B','C','D','E','F','0','1','2','3','4','5','6','7','8','9']
			return value.split("").filter(item => permitted_chars.includes(item)).join("")
		}
		var file_bytes = []
		var viewed_file = -1;

		function hex(val) {
			return "0x" + val.toString(16).toUpperCase()
		}

		function str(val) {
			return val.toString()
		}

		function len(arr) {
			return arr.length;
		}

		class Code {
			constructor(index, output=null, parameters, name=null) {
				this.index = index;
				if (output == null) {
					this.output = (params) => {return [`function${index}(${params.join(", ")})`]};
				} else {
					this.output = output;
				}
				this.parameter_names = [...parameters]
				this.param_count = parameters.length;
				let args = ["arg0", "arg1", "arg2", "arg3"]
				if (index == 10) {
					args = [0, "arg1", "arg2", "arg3"]
				}
				this.tooltip = this.output(args);
				if (name == null) {
					this.name = this.tooltip[0]
				} else {
					this.name = name;
				}
			}
		}

		function getDurationText(duration, item) {
			return `&#128337; ${duration} frames | &#128193; Item ${item.segment}`
		}

		function convertScriptLine(item) {
			if (item["code"]) {
				return `${item["code"]}`.replaceAll("\n","<br>")
			} else if (item["points"]) {
				return item["points"]
					.map((point, index) => `<strong>Point ${index}:</strong> ${point['x']}, ${point['y']}, ${point['z']}`)
					.join("<br>")
			} else {
				text = [`${item["read"]}`]
			}
			return text.join(", ")
		}

		function intToArr(val,size) {
			ret = []
			for (let a = 0; a < size; a++) {
				ret.push(0)
			}
			left = val;
			idx = size - 1;
			while (idx > -1) {
				ret[idx] = left % 256;
				left = (left - ret[idx]) / 256;
				idx -= 1;
				if (idx == -1) {
					break;
				} else if (left == 0) {
					break;
				}
			}
			return ret.slice()
		}

		function analyzeDiff(original, newfile, expect_complete) {
			let print_lim = 5;
			let error_count = 0;
			if ((expect_complete) && (original.length != newfile.length)) {
				console.log(`Mismatched size (${original.length} != ${newfile.length})`)
				error_count += 1
				print_lim -= 1
			}
			for (let i = 0; i < Math.min(original.length, newfile.length); i++) {
				if (original[i] != newfile[i]) {
					error_count += 1
					if (print_lim > 0) {
						console.log(`Byte Mismatch at 0x${i.toString(16)} (${original[i]} != ${newfile[i]})`)
					}
					print_lim -= 1
				}
			}
			if (error_count == 0) {
				console.log("Matched Bytes")
			} else {
				console.log(`${error_count} Errors`)
			}
		}

		function purgeUnusedItems() {
			// Add original point index to obejct
			reference_data = {}
			cutscene_data["points"] = cutscene_data["points"].map((item, index) => {
				return {
					...item,
					...{"original_segment": item.segment}	
				}
			})
			cutscene_data["points"].forEach(point => {
				reference_data[point.segment] = 0
			})
			cutscene_data["cutscenes"].forEach(cutscene => {
				cutscene.point_sequence.forEach(point => {
					if (Object.keys(reference_data).includes(point)) {
						reference_data[point] += 1;
					}
				})
			})
			cutscene_data["points"].forEach(point => {
				if (Object.keys(reference_data).includes(point.segment)) {
					point.references = reference_data[point.segment]
				}
			})
			const unused_count = cutscene_data["points"].filter(item => item.references == 0).length
			const original_count = cutscene_data["points"].length
			cutscene_data["points"] = cutscene_data["points"].filter(item => item.references > 0) // Purge all unused points
			// Reallocate cutscenes to use the shortened point file
			let conversion = {}
			cutscene_data["points"].forEach((item, index) => {
				conversion[item["original_segment"]] = item.segment
			})
			cutscene_data["cutscenes"].forEach(cutscene => {
				cutscene.point_sequence.forEach((point, index) => {
					if (Object.keys(conversion).includes(point)) {
						cutscene.point_sequence[index] = conversion[point]
					}
				})
			})
			cutscene_data["points"].forEach(point => {
				point.segment = conversion[point.segment]
			})
			console.info(`${unused_count}/${original_count} items purged for being unused.`)
			showScript(viewed_file)
			saveCutscenesToFile(false, true);
		}

		function addCutscene() {
			const added = cutscene_data["cutscenes"].length;
			cutscene_data["cutscenes"].push({
				"index": added,
				"count": 0,
				"point_data": [],
				"point_sequence": [],
				"point_durations": [],
			})
			populateSelectList(cutscene_data);
			viewed_file = added;
			showScript(added);
		}

		function emptyCutscene() {
			console.log(cutscene_data["cutscenes"])
			cutscene_data["cutscenes"].find(item => item.index == viewed_file).point_sequence = []
			cutscene_data["cutscenes"].find(item => item.index == viewed_file).point_durations = []
			cutscene_data["cutscenes"].find(item => item.index == viewed_file).point_data = []
			cutscene_data["cutscenes"].find(item => item.index == viewed_file).count = 0
			showScript(viewed_file)
		}

		function removeCutscene() {
			if (cutscene_data["cutscenes"].length > 0) {
				cutscene_data["cutscenes"] = cutscene_data["cutscenes"].filter((item, index) => item.index < (cutscene_data["cutscenes"].length - 1));
				populateSelectList(cutscene_data);
			} else {
				console.log("No cutscenes to remove!")
			}
		}

		let new_file = []
		function saveCutscenesToFile(force_download, get_file_size_diff) {
			let dump_data = {}
			// Write Header
			new_file = [... cutscene_data["header_data"].slice()]
			// Cutscene Point Sequences
			new_file = new_file.concat(intToArr(cutscene_data["cutscenes"].length, 2))
			cutscene_data["cutscenes"].forEach(cutscene => {
				point_size = Math.min(cutscene["point_sequence"].length, cutscene["point_durations"].length)
				new_file = new_file.concat(intToArr(point_size, 2))
				for (let j = 0; j < point_size; j++) {
					new_file = new_file.concat(intToArr(cutscene["point_sequence"][j], 2))
					new_file = new_file.concat(intToArr(cutscene["point_durations"][j], 2))
				}
			})
			// Item Data
			filter_arr = [1, 2, 3, 4, 5, 10, 15, 16, 12, 13]
			filtered_item_count = cutscene_data["points"].filter(item => filter_arr.includes(item.command)).length
			new_file = new_file.concat(intToArr(filtered_item_count, 2))
			cutscene_data["points"].forEach((item, index) => {
				new_file.push(item["unk0"])
				command = item["command"]
				new_file.push(command)
				switch (command) {
					case 1:
						new_file = new_file.concat(item["head"])
						new_file = new_file.concat(item["read"])
						break;
					case 2:
						new_file = new_file.concat(item["head"])
						new_file = new_file.concat(item["read"])
						break;
					case 3:
					case 13:
						new_file = new_file.concat(item["head"])
						if (command == 3) {
							new_file = new_file.concat(item["read"])
						} else {
							cmd_data = item["detailed_command"]
							new_file = new_file.concat(intToArr(cmd_data["sub_command"], 4))
							occupied_space = 4
							cmd_data["params"].forEach(param => {
								new_file = new_file.concat(intToArr(param, 2))
								occupied_space += 2
							})
							new_file = new_file.concat(intToArr(0, 12-occupied_space))
						}
						break;
					case 4:
						new_file = new_file.concat(item["head"])
						start = {
							...item["point_start"]
						}
						start["x"] = item["points"].length
						point_list = [start, item["point_end"]]
						point_list = point_list.concat(item["points"])
						point_list.forEach(point => {
							const coord_bases = ["x","y","z"]
							coord_bases.forEach(coord => {
								val = point[coord]
								if (val < 0) {
									val += 65536
								}
								new_file = new_file.concat(intToArr(val, 2))
							})
							coord_bases.forEach(coord => {
								val = point["rot"][coord]
								if (val < 0) {
									val += 65536
								}
								new_file = new_file.concat(intToArr(val, 2))
							})
							new_file.push(point["zoom"])
							new_file.push(point["roll"])
						})
						break;
					case 5:
						new_file = new_file.concat(item["head"])
						start = {
							...item["point_start"]
						}
						start["x"] = item["points"].length
						point_list = [start, item["point_end"]]
						point_list = point_list.concat(item["points"])
						point_list.forEach(point => {
							["x","y","z"].forEach(coord => {
								val = point[coord]
								if (val < 0) {
									val += 65536
								}
								new_file = new_file.concat(intToArr(val, 2))
							})
							new_file.push(point["zoom"])
							new_file.push(point["roll"])
						})
						break;
					case 10:
					case 15:
					case 16:
						new_file = new_file.concat(item["head"])
						new_file = new_file.concat(item["read"])
						break;
					case 12:
						new_file = new_file.concat(item["head"])
						new_file = new_file.concat(item["song"])
						break;
					default:
						new_file = new_file.concat(item["head"])
						new_file = new_file.concat(item["read"])
						break;
				}
			})
			if (get_file_size_diff) {
				console.log(`Old file size: ${file_bytes.length} bytes`)
				console.log(`New file size: ${new_file.length} bytes`)
				console.log(`Reduction: ${100 - ((Math.floor((new_file.length / file_bytes.length) * 1000)) / 10)}%`)
			}
			// analyzeDiff(file_bytes, new_file, true);
			if (force_download) {
				writeToFile();
			}
			//console.log(new_file)
		}

		function writeToFile() {
			var write_bytes = new Uint8Array(new_file.length);
			new_file.forEach((item,index) => {write_bytes[index] = item})
			var saveByteArray = (function () {
				var a = document.createElement("a");
				document.body.appendChild(a);
				a.style = "display:none";
				return function (data, name) {
					var blob = new Blob(data, {type: "octet/stream"}),
					url = window.URL.createObjectURL(blob);
					a.href = url;
					a.download = name;
					a.click();
					a.remove();
				};
			}())
			saveByteArray([write_bytes],'output.bin')
		}

		function initAddItem() {
			document.getElementById("new-item-index").value = "";
			togglePromptState('new-item',false)
		}

		var edit_data = {};
		var point_data = {};
		var edit_line = 0;
		var edit_duration = 0;

		function updateCommand(update) {
			point_data["command"] = parseInt(document.getElementById("command-select").value);
			if (point_data["command"] == 13) {
				if (!Object.keys(point_data).includes("detailed_command")) {
					const param_length= codeBlocks.find(item => item.index == 0).param_count;
					point_data["detailed_command"] = {
						"sub_command": 0,
						"params": new Array(param_length).fill(0),
					}
				}
			}
			if (update) {
				updateControls(false);
			}
		}

		function updateSubcommand(update) {
			const val = parseInt(document.getElementById("subcommand-select").value)
			const matching_functions = codeBlocks.filter(item => item.index == val)
			let param_length = 4;
			if (matching_functions.length > 0) {
				param_length = matching_functions[0].param_count;
			}
			if (Object.keys(point_data).includes("detailed_command")) {
				if (val != point_data["detailed_command"]["sub_command"]) {
					point_data["detailed_command"]["sub_command"] = new Array(param_length).fill(0);
				}
				point_data["detailed_command"]["sub_command"] = val;
			} else {
				point_data["detailed_command"] = {
					"sub_command": val,
					"params": new Array(param_length).fill(0),
				}
			}
			if (update) {
				updateControls(false);
			}
		}

		function updateSubcommandParameters(update) {
			point_data["detailed_command"]["params"].forEach((item, index) => {
				if (document.getElementById(`subcommand-field-${index}`) != null) {
					if (document.getElementById(`subcommand-field-${index}`).value == "") {
						point_data["detailed_command"]["params"][index] = 0
					} else {
						point_data["detailed_command"]["params"][index] = parseInt(document.getElementById(`subcommand-field-${index}`).value)
					}
				}
			})
			if (update) {
				updateControls(true);
			}
		}

		function updateSong(update) {
			point_data["song"] = parseInt(document.getElementById("input-song").value);
			if (update) {
				updateControls(false);
			}
		}

		function updateDuration(update) {
			if (document.getElementById("duration-specify").value == "") {
				edit_duration = 0;
			} else {
				edit_duration = parseInt(document.getElementById("duration-specify").value)
			}
			if (update) {
				updateControls(false);
			}
		}

		function removePoint(target_index) {
			point_data["points"] = point_data["points"].filter((item, index) => index != target_index)
			updateControls(false);
		}

		function pushPoint(include_rotation, update) {
			push_obj = {
				"x": 0,
				"y": 0,
				"z": 0,
				"zoom": 45,
				"roll": 0,
			}
			if (include_rotation) {
				push_obj["rot"] = {
					"x": 0,
					"y": 0,
					"z": 0,
				}
			}
			point_data["points"].push(push_obj)
			if (update) {
				updateControls(false);
			}
		}

		function updateAllControls() {
			if (point_data["command"] == 12) {
				updateSong(false);
			} else if (point_data["command"] == 13) {
				updateSubcommand(false);
				updateSubcommandParameters(false);
			}
			updateDuration();
			updateEmptyScripts();
		}

		function updateCutscenePoints() {
			point_data["points"].forEach((point, index) => {
				const standard_axes = ["x", "y", "z"]
				standard_axes.forEach(coord => {
					if (document.getElementById(`point-define-pos-${index}-${coord}`).value == "") {
						point[coord] = 0
					} else {
						point[coord] = document.getElementById(`point-define-pos-${index}-${coord}`).value
					}
					if (point_data["command"] == 4) {
						if (document.getElementById(`point-define-rot-${index}-${coord}`).value == "") {
							point["rot"][coord] = 0
						} else {
							point["rot"][coord] = document.getElementById(`point-define-rot-${index}-${coord}`).value
						}
					}
				})
				const extra = ["zoom", "roll"];
				extra.forEach(ex => {
					if (document.getElementById(`point-define-misc-${index}-${ex}`).value == "") {
						point[ex] = 0
					} else {
						point[ex] = document.getElementById(`point-define-misc-${index}-${ex}`).value
					}
				})
			})
			updateControls(true);
		}

		function updateControls(preview_only) {
			var hook = document.getElementById("item-controls")
			const command_names = {
				4: "Points (Detailed)",
				5: "Points",
				12: "Play Song",
				13: "Function",
			}
			const command_indexes = [...Array(16).keys()].map(item => item + 1)
			if (!preview_only) {
					hook.innerHTML = `
						<div class="flex-container">
							<div class="flex-item">
								<label for="command-select">Command</label>
								<select name="command" id="command-select" onchange="updateCommand(true);">
									${command_indexes.map(item => 
										`
											<option
												value="${item}"
												class="command-item-${Object.keys(command_names).includes(item.toString()) ? "used" : `unused ${point_data["command"] == item ? "" : "hide"}`}"
												${point_data["command"] == item ? "selected" : ""}
											>
												${(Object.keys(command_names).includes(item.toString())) ? command_names[item] : `Command ${item}`}
											</option>
										`
									).join("")}
								</select>
							</div>
							<div class="flex-item">
								<label for="duration-specify">Duration</label>
								<input type-"number" id="duration-specify" value="${edit_duration}" onfocusout="updateDuration(true);" style="width: 100px">
							</div>
						</div>
						<hr>
						${([4, 5].includes(point_data["command"]) ?
							`${point_data["points"].map((item, index) => `
								<div class="flex-container">
									<div class="flex-item">
										<strong>Point ${index + 1}</strong>
									</div>
									<div class="flex-item" style="text-align:right">
										<button class="point-button-hidetoggle" onclick="document.getElementById('point-group-${index}').classList.toggle('hide')">&#128065;</button>
										<button class="point-button-remove" onclick="removePoint(${index});">&#10799;</button>
									</div>
								</div>
								<div id="point-group-${index}" ${index > 0 ? "class='hide'" : ""}>
									<div>Positions</div>
									<div class="flex-container">
										${["x", "y", "z"].map(item2 => `
											<div class="flex-item">
												<label for="point-define-pos-${index}-${item2}">${item2}</label>
												<input type="number" id="point-define-pos-${index}-${item2}" value="${item[item2]}" onfocusout="updateCutscenePoints();" style="width: 100px">
											</div>
										`).join("")}
									</div>
									<br>
									${point_data["command"] == 4 ? `
										<div>Rotations</div>
										<div class="flex-container">
											${["x", "y", "z"].map(item2 => `
												<div class="flex-item">
													<label for="point-define-rot-${index}-${item2}">${item2}</label>
													<input type="number" id="point-define-rot-${index}-${item2}" value="${item["rot"][item2]}" onfocusout="updateCutscenePoints();" style="width: 100px">
												</div>
											`).join("")}
										</div>
										<br>
									` : ""}
									<div>Miscellaneous</div>
									<div class="flex-container">
										${["zoom", "roll"].map(item2 => `
											<div class="flex-item">
												<label for="point-define-misc-${index}-${item2}">${item2}</label>
												<input type="number" id="point-define-misc-${index}-${item2}" value="${item[item2]}" onfocusout="updateCutscenePoints();" style="width: 100px">
											</div>
										`).join("")}
									</div>
								</div>
								<hr>
							`).join("")}
							<button class="point-button-add" style="width:100%" onclick="pushPoint(${point_data["command"] == 4}, true);">Add Point</button>
							`
						: (point_data["command"] == 12 ?
							`<div class="flex-container">
								<div style="margin-left:auto;margin-right:auto;">
									<label for="input-song">Song</label>
									<select id="input-song" onchange="updateSong(true);">
										${songs.map((item, index) => `
											<option value=${index} ${(point_data["song"] == index ? "selected" : "")}>
												${item}
											</option>
										`)}
										</select>
									</div>
								</div>
							</div>
							<div class="flex-container">
								<div class="preview-head">Preview</div>
							</div>
							<div class="code" id="preview_text">
								${`playSong('${songs[point_data['song']]}');`}
							</div>`
						: (point_data["command"] == 13 ?
							`<div class="flex-container">
								<div class="flex-item">
									<label for="subcommand-select">Sub-Command</label>
									<select name="subcommand" id="subcommand-select" onchange="updateSubcommand(true);">
										${codeBlocks.map(item => 
											`
												<option
													value="${item.index}"
													title="${item.tooltip.join("\n")}"
													${point_data["detailed_command"]["sub_command"] == item.index ? "selected" : ""}
												>
													${item.name}
												</option>
											`
										).join("")}
									</select>
								</div>
							</div>
							${codeBlocks.find(item => item.index == point_data["detailed_command"]["sub_command"]).parameter_names.map((item, index) => 
								`
									<div>
										<label for="subcommand-field-${index}">${item}</label>
										<input type="text" id="subcommand-field-${index}" value="${point_data["detailed_command"]["params"][index]}" onkeyup="updateSubcommandParameters(true);">
									</div>
								`
							).join("")}
							<div class="flex-container">
								<div class="preview-head">Preview</div>
							</div>
							<div class="code" id="preview-text">
								${codeBlocks.find(item => item.index == point_data["detailed_command"]["sub_command"]).output(point_data["detailed_command"]["params"]).map(item => item.trim()).join("<br>")}
							</div>
							`
						:
							`<div>Command ${point_data['command']}</div>`
						)))}
					`
			} else {
				var preview_hook = document.getElementById("preview-text")
				if (point_data["command"] == 13) {
					preview_hook.innerHTML = `${codeBlocks.find(item => item.index == point_data["detailed_command"]["sub_command"]).output(point_data["detailed_command"]["params"]).map(item => item.trim()).join("<br>")}`
				} else if (point_data["command"] == 12) {
					preview_hook.innerHTML = `${`playSong('${songs[point_data['song']]}');`}`
				}
			}
			updateEmptyScripts();
		}

		function pushPrompt() {
			/*
				<div class="new_item prompt hide" id="new-item">
					<div class="head">
						Add Script Item
					</div>
					<label for="new-item-index">New Script ID: 0x</label>
					<input id="new-item-index" type="text" pattern="[a-fA-F0-9]{1,4}" maxlength="4" onkeyup="this.value = filterNewItemInput(this.value)"/>
					
				</div>

			*/
			var hook = document.getElementById("new-item");
			const used_points = cutscene_data["points"].map(item => item.segment)
			const new_seg = Math.min(...[...Array(5000).keys()].filter(item => !used_points.includes(item)));
			point_data = {
				"command": 5,
				"points": [],
				"segment": new_seg,
				"duration": 0,
				"detailed_command": {
					"sub_command": 0,
					"params": [],
				},
				"head": [0, 0],
				"read": [],
				"song": 0,
			}
			if (Object.keys(edit_data).length > 0) {
				point_data = Object.assign({}, edit_data);
				point_data["segment"] = new_seg
			}
			hook.innerHTML = `
				<div class="head">
					${(Object.keys(edit_data).length == 0) ? "Add" : "Edit"} Point
				</div>
				<label for="new-item-index"></label>
				<div id="new-item-error" class="prompt-error"></div>
				<div id="item-controls"></div>
				<div class="button-array">
					<div class="array-item">
						<button class="cancel" onclick="togglePromptState('new-item',true)">Close</button>
					</div>
					<div class="array-item right">
						<button class="confirm" onclick="pushLine(${viewed_file}, ${edit_line})">Confirm</button>
					</div>
				</div>
			`
			updateControls();
			togglePromptState('new-item',false)
		}


		function initEditLine(file, line) {
			edit_data = cutscene_data["cutscenes"].find(item => item.index == file).point_data[line]
			edit_line = line
			edit_duration = cutscene_data["cutscenes"].find(item => item.index == file).point_durations[line]
			pushPrompt()
		}

		function initAddLine(file) {
			edit_data = {}
			edit_duration = 0
			edit_line = cutscene_data["cutscenes"].find(item => item.index == file).point_data.length
			pushPrompt();
		}

		function pushLine(file, line) {
			updateAllControls();
			point_data["duration"] = edit_duration
			if (point_data["command"] == 13) {
				code = parseSubCommand(point_data["detailed_command"]["sub_command"], point_data["detailed_command"]["params"])
				point_data["code"] = code
			} else {
				parsePoint(point_data)
				if ([4, 5].includes(point_data["command"])) {
					point_data["point_start"] = Object.assign({}, [...point_data["points"]][0]);
					point_data["point_start"]["x"] = [...point_data["points"]].length;
					point_data["point_end"] = Object.assign({}, [...point_data["points"]][0]);
				}
			}
			cutscene_data["points"].push(point_data)
			reference =  cutscene_data["cutscenes"].find(item => item.index == file)
			if (reference != null) {
				reference["point_data"][line] = point_data,
				reference["point_sequence"][line] = point_data.segment
				reference["point_durations"][line] = edit_duration
				cutscene_data["cutscenes"] = cutscene_data["cutscenes"].filter(item => item.index != file)
				cutscene_data["cutscenes"].push(reference)
				cutscene_data["cutscenes"] = cutscene_data["cutscenes"].sort((a, b) => (a.index > b.index) ? 1 : -1);
			}
			showScript(file);
			togglePromptState('new-item', true);
		}


		function removeLine(file, line) {
			old_data = cutscene_data["cutscenes"].find(item => item.index == file);
			new_cs = cutscene_data["cutscenes"].filter(item => item.index != file);
			new_cs.push({
				"count": old_data["count"] - 1,
				"index": old_data["index"],
				"point_data": old_data["point_data"].filter((item, index) => index != line),
				"point_durations": old_data["point_durations"].filter((item, index) => index != line),
				"point_sequence": old_data["point_sequence"].filter((item, index) => index != line),
			});
			cutscene_data["cutscenes"] = new_cs.sort((a, b) => (a.index > b.index) ? 1 : -1);
			showScript(file);
		}

		function showScript(script_index) {
			if (script_index != -1) {
				viewed_file = script_index;
				items = document.getElementsByClassName("map-item")
				for (let i = 0; i < items.length; i++) {
					if (items[i].getAttribute("id-index").toString() == script_index.toString()) {
						items[i].classList.add("viewed-index")
					} else {
						items[i].classList.remove("viewed-index")
					}
				}
				hook = document.getElementById("cutscene_script_display")
				hook.innerHTML = ""
				var focused_cs = cutscene_data["cutscenes"].find(item => item.index == script_index)
				if (focused_cs) {
					hook.innerHTML = `
						${focused_cs.point_data.map((item, index) =>	`
							<div class='code_item'>
								<div class='flex-container'>
									<div class='flex-item' style='flex:5'>
										<div class='code_duration'>${getDurationText(focused_cs.point_durations[index], item)}</div>
										<div class='code_sample'>${convertScriptLine(item)}</div>
									</div>
									<div class='flex-item' style='text-align:right'>
										<button class='code-item-edit' onclick='initEditLine(${script_index}, ${index})'>&#9998;</button>
										<button class='code-item-remove' onclick='removeLine(${script_index}, ${index})'>&#10799;</button>
									</div>
								</div>
							</div>
						`).join("")}
						<button onclick="initAddLine(${script_index})" class="code-item-add">Add Item</button>
					`
				}
			}
			updateEmptyScripts();
		}

		function populateSelectList(cutscene_data) {
			var hook = document.getElementById("map-select")
			hook.innerHTML = "";
			cutscene_data["cutscenes"].forEach((item,index) => {
				var item_div = document.createElement("div")
				var item_text = document.createTextNode(`Cutscene ${index}`);
				item_div.classList.add("map-item")
				item_div.setAttribute("id-index",index.toString())
				item_div.appendChild(item_text)
				item_div.setAttribute("onclick",`showScript(${index})`)
				hook.appendChild(item_div)
			})
			updateCutsceneNames();
			updateEmptyScripts();
		}

		document.getElementById("file-selector").addEventListener("change", function() {
			var fr = new FileReader();
			fr.onload = function() {
				var data = fr.result;
				setup_data = fr.result;
			    var array = new Uint8Array(data);
			    file_bytes = array.slice()
				document.getElementById("form-controls").classList.remove("hide")
			    let cutscene_data = parseFile();
			    populateSelectList(cutscene_data);
			};
			fr.readAsArrayBuffer(document.getElementById("file-selector").files[0]);
        })
		document.getElementById("import-selector").addEventListener("change", function() {
			var fr = new FileReader();
			fr.onload = function() {
				var data = fr.result;
				var enc = new TextDecoder("utf-8");
				var arr = data;
				importScript(enc.decode(arr));
			};
			fr.readAsArrayBuffer(document.getElementById("import-selector").files[0]);
        })		

		function getTriggerTypeName(index) {
			if (index < (len(trigger_types) - 1)) {
				return trigger_types[index]
			}
			return "Type %s" % (hex(index))
		}

		function getSongName(index) {
			if (index < (len(songs) - 1)) {
				return songs[index]
			}
			return "Song %s" % (hex(index))
		}

		function getTOrF(value) {
			if (value == 0) {
				return "False"
			}
			return "True"
		}

		function getSetOrNot(value) {
			if (value == 0) {
				return "Don't Set"
			}
			return "Set"
		}

		var tab_indentation = 0;
		var main_pointer_table_offset = 0x101C50;
		function display(file, str, args) {
			hook = document.getElementById("c_comparison")
			str = str.toString()
			if (args) {
				if (args.length > 0) {
					str_arr = str.split("%s")
					str = ""
					str_arr.forEach((item,index)=> {
						str += str_arr[index]
						if (index < (str_arr.length - 1)) {
							str += args[index]
						}
					})
				}
			}
			if (str.substring(str.length - 1) != "{") {
				if (str.substring(str.length - 1) != "}") {
					str += ";"
				}
			}
			line_tabbing = 0
			for (let x = 0; x < tab_indentation; x++) {
				line_tabbing += 1
			}
			if (str.substring(str.length - 1) == "{") {
				tab_indentation += 1;
			} else if (str.substring(str.length - 1) == "}") {
				tab_indentation -= 1;
			}
			var block = document.createElement("div")
			block.classList.add("assoc-line-" + current_numeric_line.toString())
			var block_text = document.createTextNode(str)
			block.setAttribute("tabbing",line_tabbing);
			block.classList.add("code-line")
			block.appendChild(block_text)
			hook.appendChild(block)
			//hook.innerText += str + "\n"
			//file.write(string + "\n")
		}

		function fixTabbing() {
			var hooks = document.getElementsByClassName("code-line")
			for (let h = 0; h < hooks.length; h++) {
				hooks[h].style["padding-left"] = (parseInt(hooks[h].getAttribute("tabbing")) * 20).toString() + "px"
			}
		}

		function togglePromptState(prompt_id,shown) {
			if (shown) {
				document.getElementById(prompt_id).classList.add("hide")
				document.getElementById("blocker").classList.add("hide")
			} else {
				document.getElementById(prompt_id).classList.remove("hide")
				document.getElementById("blocker").classList.remove("hide")
			}
			updateEmptyScripts();
		}

		function hexToFloat(hx_) {
			return hx_
		}

		codeBlocks = [
			new Code(0, (params_lst) => {
				return [
					`Player->paad->field_6C = ${params_lst[0]};`,
					"Player->paad->field_70 = Player->rotation.x;",
					`Player->paad->field_74 = ${params_lst[1]};`,
					"setCharacterChangeParameters(BBlast,0x0,0);"
				]
			}, ["paad->6C", "paad->74"]),
			new Code(1, (params_lst) => {
				return [
					`handleRap(${params_lst[3]},0,200,${params_lst[0]};`
				]
			}, ["param 4", "?", "?", "param 1"]),
			new Code(2, (params_lst) => {return ["Player->paad->field_1F0 |= 8;"]}, []),
			new Code(3, (params_lst) => {return ["Player->paad->field_1F0 &= 0xFFFFFFF7;"]}, []),
			new Code(4, (params_lst) => {
				if (params_lst[0] == 0) {
					if (params_lst[1] == 2) {
						code = [
							"Player->rendering_params->field_10 = 0xFFFF;",
							"displaySprite(Player,0x80747750);"
						]
						if (params_lst[2] > 0) {
							code.push(`FUN_80614D00(Player,${params_lst[2]},0);`)
						}
						return code
					}
				}
				return [
					`FUN_80724994(3,${params_lst[0]},${params_lst[1]},${params_lst[2]});`
				]
			}, ["short (0) or long (1) function", "short (!= 2) or long (2) function", "param 2 in extra function"]),
			new Code(5, (params_lst) => {
				return [
					`spawnCharacter(${params_lst[0]},0,0,0,0,0,0);`
				]
			}, ["param 1"]),
			new Code(6, (params_lst) => {
				return [
					`void* uvar0 = getSpawnerTiedActor(${params_lst[0]});`,
					`setCutsceneTarget(uvar0,${params_lst[1] & 0xFF});`
				]
			}, ["tied actor id", "setCutsceneTarget Param 2"], "Set Cutscene Target"),
			new Code(7, (params_lst) => {
				return [
					`changeCutsceneState(${params_lst[0] & 0xFF},${params_lst[1] & 0xFF})`
				]
			}, ["param 1", "param 2"], "Change Cutscene State"),
			new Code(8, (params_lst) => {
				return [
					`setCutsceneIndex(${params_lst[0] & 0xFF});`
				]
			}, ["Cutscene Index"], "Set Cutscene Index"),
			new Code(9, (params_lst) => {
				return [
					`FUN_8061DAAC(${params_lst[0]},${params_lst[1]},${params_lst[2]});`
				]
			}, ["Param 1", "Param 2", "Param 3"]),
			new Code(10, (params_lst) => {
				if (params_lst[0] == 0) {
					code = [
						"void* uvar0 = getSpawnerTiedActor(1,0);",
						"int uvar1 = 2;",
						"while (uvar0 != 0) {",
					]
					if (params_lst[1] == 0) {
						code.push("Player->obj_params_bitfield &= 0xFFFFFFFB;")
					} else {
						code.push("Player->obj_params_bitfield |= 4;")
					}
					return code.concat([
						"uvar0 = getSpawnerTiedActor(uvar1,0);",
						"uvar1 += 1;",
						"}"
					])
				}
				return []
			}, ["Enable Function (0)", "Show (1) or Hide (0)"]),
			new Code(11, (params_lst) => {
				return [
					`FUN_807289E8(${params_lst[0]},${params_lst[1]},${params_lst[2]},${params_lst[3]});`
				]
			}, ["Param 1", "Param 2", "Param 3", "Param 4"]),
			new Code(12, (params_lst) => {
				return [
					`int uvar0 = ${params_lst[0]};`,
					`FUN_8067AB20(CameraPointer,${params_lst[1]},0,1,&uvar0,0);`
				]
			}, ["Uvar0 Value", "Param 2"]),
			new Code(13, (params_lst) => {
				return [
					`int uvar0 = ${params_lst[0]};`,
					`FUN_8067AB20(CameraPointer,${params_lst[1]},0,0x10,&uvar0,0);`,
					"int sstack = 0xFFFF;",
					`FUN_8067AB20(CameraPointer,${params_lst[1]},0,0xE,&uvar0,0);`
				]
			}, ["Uvar0 Value", "Param 2"]),
			new Code(14, (params_lst) => {
				return [
					`FUN_80729AA4(${params_lst[0] & 0xFF});`
				]
			}, ["Param 1"]),
			new Code(15, (params_lst) => {
				return [
					`command_15(${params_lst[0]},${params_lst[1]},${params_lst[2]},${params_lst[3]})`
				]
			}, ["Param 1", "Param 2", "Param 3", "Param 4"]),
			new Code(0x10, (params_lst) => {
				return [
					`FUN_8061F0B0(CameraPointer,${params_lst[1] & 0xFF},${params_lst[0]});`
				]
			}, ["Param 2", "Param 3"]),
			new Code(0x11, (params_lst) => {
				return [
					`FUN_806291B4(${params_lst[0] & 0xFF});`
				]
			}, ["Param 1"]),
			new Code(0x12, (params_lst) => {
				return [
					`int uvar0 = ${params_lst[0]};`,
					`FUN_8067AB20(CameraPointer,${params_lst[1]},0,0x14,&uvar0,0);`
				]
			}, ["Uvar0 Value", "Param 2"]),
			new Code(0x13, (params_lst) => {
				if (params_lst[0] == 0) {
					code = [
						"int* uvar0 = Player;",
						"FUN_80672C30(Player);"
					]
				} else {
					code = [
						`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`
					]
				}
				return code.concat([
					`FUN_80724B5C(${params_lst[1]&0xFF},${params_lst[2]&0xFF},uvar0->xPos,uvar0->yPos,uvar0->zPos);`,
					"int* uvar1 = uvar0;",
					"FUN_8067A69C(0, uvar0, uvar0->xPos, uvar0->zPos, 2, 1);",
					"float fvar0 = uvar0->yPos;",
					`int uvar2 = ${parseInt((params_lst[1] << 0xC) / 0x168)};`,
					"uvar0->rotation.z = uvar2;",
					"uvar0->rotation.x = uvar2;",
					"uvar0->field_9C = fvar0;",
					"renderActor(uvar0,0);",
					"FUN_80614A64(uvar0);",
				])
			}, ["Spawner Tied Actor ID (>0) or Player (0)", "Param 1", "Param 2"]),
			new Code(0x14, (params_lst) => {
				if (params_lst[0] > 0x7FF) {
					if (params_lst[1] < 0x800) {
						code = ["double dvar0 = DOUBLE_807580C8;"]
						if (params_lst[0] != 0) {
							code.push(`dvar0 = (${params_lst[0]}/DOUBLE_807580B8) * DOUBLE_807580C0;`)
						}
						return code.concat([
							"if (dvar0 < 0) {",
							"dvar0 = -1;",
							"}",
							`playSFX_LowLevel(SFXLowerBank,${params_lst[1]},dvar0,0x3F);`
						])
					} else {
						code = ["double dvar0 = DOUBLE_807580E8;"]
						if (params_lst[0] != 0) {
							code.push(`dvar0 = (${params_lst[0]}/DOUBLE_807580D8) * DOUBLE_807580E0;`)
						}
						return code.concat([
							"if (dvar0 < 0) {",
							"dvar0 = -1;",
							"}",
							`playSFX_LowLevel(SFXUpperBank,${params_lst[1]-0x7FF},dvar0,0x3F);`,
						])
					}
				} else {
					code = ["int uvar0 = 0;"]
					if (params_lst[0] == 0) {
						code.push("void* uvar1 = Player;")
						code.push("void* uvar2 = Player;")
					} else {
						code.push(`void* uvar2 = getSpawnerTiedActor(${params_lst[0]},0);`)
					}
					return code.concat([
						`*(short*)(0x807F5D7C) = FUN_806086CC(0,0,uvar2->zPos,${params_lst[1] & 0xFF});`
					])
				}
			}, ["Param 1", "Param 2"], "Play SFX at location"),
			new Code(0x15, (params_lst) => {
				return [
					`modifyObjectState(${params_lst[0]},${params_lst[1]&0xFF});`
				]
			}, ["Object ID", "Target State"], "Modify Object Model 2 Instance State"),
			new Code(0x16, (params_lst) => {
				return [
					`void* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`,
					"if (uvar0 != 0) {",
					"if ((*(int*)(0x807FBB68) & 2) == 0) {",
					"attachActorToVehicle(Player,uvar0,0x3E19999A);",
					"character_change_pointer->field_2C0 = 1",
					"} else {",
					"attachActorToVehicle(Player,uvar0,uvar0->rendering_params->field_38);",
					"}",
					"clearTagSlide(Player);",
					"Player->obj_params_bitfield |= 4;",
					"uvar0->control_state = 0x40;",
				]
			}, ["Spawner ID"], "Attach actor to Vehicle"),
			new Code(0x17, (params_lst) => {
				if (params_lst[1] == 0) {
					return [
						`playSong(${params_lst[0]},f12);`
					]
				}
				return [
					`playSong(${params_lst[0]},${params_lst[1]}/DOUBLE_807580F8);`
				]
			}, ["Song Index", "Volume"], "Play Song"),
			new Code(0x18, (params_lst) => {
				return ["FUN_8070E8DC(1);"]
			}, []),
			new Code(0x19, (params_lst) => {
				uvar0 = params_lst[0]
				if (params_lst[0] < 1) {
					uvar0 = -params_lst[0]
				}
				if (uvar0 < 1) {
					return ["FUN_80737924((&DAT_807F5D70)[0]);"]
				}
				uvar1 = -params_lst[0]
				if (params_lst[0] > 0) {
					uvar1 = params_lst[0]
				}
				return [
					`int uvar1 = ${uvar1}`,
					"FUN_80737924((&DAT_807F5D70)[uvar]);",
				]
			}, ["?"]),
			new Code(0x1A, (params_lst) => {
				return ["FUN_80737924(SFXArray[*(short*)(0x807F5D7C)]);"]
			}, []),
			new Code(0x1B, (params_lst) => {
				return [`cancelMusic(${params_lst[0]},0);`]
			}, ["Song"], "Cancel Music"),
			new Code(0x1C, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					"uvar0->rotation.x = character_change_pointer->field_2C8 & 0xFFF;"
				]
			}, ["Spawner ID (>0) or Player (0)"]),
			new Code(0x1D, (params_lst) => {
				return ["pauseCutscene();"]
			}, [], "Pause Cutscene"),
			new Code(0x1E, (params_lst) => {
				return [
					"spawnActorWrapper(0x108,0x1D);",
					`PTR_DAT_807FBB44->text_file = ${params_lst[0]}`,
					`loadText(PTR_DAT_807FBB44,${params_lst[0]},${params_lst[1]&0xFF});`,
				]
			}, ["Text File", "Text Index"], "Spawn Squawks with Text"),
			new Code(0x1F, (params_lst) => {
				return [
					`command_31(${params_lst[0]},${params_lst[1]},${params_lst[2]},${params_lst[3]})`
				]
			}, ["Param 1", "Param 2", "Param 3", "Param 4"]),
			new Code(0x20, (params_lst) => {
				return [
					`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`,
					"if (uvar0 != 0) {",
					"attachActorToVehicle(uvar0,Player,Player->rendering_params->field_38)",
					"uvar0->control_state = 0x77;",
					"uvar0->control_state_progress = 0;",
					"}",
				]
			}, ["Spawner ID"]),
			new Code(0x21, (params_lst) => {
				return ["FUN_8061C2C4(CameraPointer,0x8000);"]
			}, []),
			new Code(0x22, (params_lst) => {
				if (params_lst[0] == 0) {
					return ["deathwarp(Player);"]
				}
				return [`initMapChange(${params_lst[0]},${params_lst[1]});`]
			}, ["Deathwarp (0) or Map (>0)", "Exit"], "Warp to Map/Deathwarp if map is 0"),
			new Code(0x23, (params_lst) => {
				return [
					`TransitionSpeed = ${params_lst[1]};`,
					`TransitionType = ${params_lst[0]};`,
				]
			}, ["Transition Speed", "Transition Type"], "Set Transition Properties"),
			new Code(0x24, (params_lst) => {
				return [
					`FUN_80724994(1,${params_lst[0]},${params_lst[1]},${params_lst[2]});`
				]
			}, ["Param 2", "Param 3", "Param 4"]),
			new Code(0x25, (params_lst) => {
				return ["FUN_806F397C();"]
			}, []),
			new Code(0x26, (params_lst) => {
				return [`FUN_80641874(${params_lst[0]},${params_lst[1]});`]
			}, ["Param 1", "Param 2"]),
			new Code(0x27, (params_lst) => {
				return [
					`FUN_80656E58(${params_lst[0]}, ${params_lst[1] & 0xFF}, 0, ${params_lst[2]});`,
					`FUN_80656E58(${params_lst[0]}, ${params_lst[1] & 0xFF}, 1, ${params_lst[2]});`,
					`FUN_80656E58(${params_lst[0]}, ${params_lst[1] & 0xFF}, 2, ${params_lst[2]});`,
					`FUN_80656E58(${params_lst[0]}, ${params_lst[1] & 0xFF}, 3, ${params_lst[2]});`,
				]
			}, ["Param 1", "Param 2", "Param 3"]),
			new Code(0x28, (params_lst) => {
				return [
					`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`,
					`int* uvar1 = getSpawnerTiedActor(${params_lst[1]},0);`,
					"if ((uvar0 != 0) && (uvar1 != 0)) {",
					"attachActorToVehicle(uvar0,uvar1,uvar1->rendering_params->field_38);",
					"FUN_80613CA8(uvar0,uvar1->rendering_params->field_10,uvar1->rendering_params->field_4,0);",
					"FUN_8061421C(uvar0);",
					"uvar0->obj_params_bitfield |= 4;",
					"uvar1->obj_params_bitfield &= 0xFFFFFFFB;",
					"}",
				]
			}, ["Spawner ID 1", "Spawner ID 2"]),
			new Code(0x29, (params_lst) => {
				return [
					"if (isISGActive() == 0) {",
					`initTransitionWGamemode(${params_lst[0]},${params_lst[1]});`,
					"}",
				]
			}, ["Map", "Cutscene"], "Initiate Transition to Map with ISG Check"),
			new Code(0x2A, (params_lst) => {
				return [
					`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`,
					"if (uvar0 != 0) {",
					"uvar0->control_state = 0x3C;",
					"}",
				]
			}, ["Spawner ID"]),
			new Code(0x2B, (params_lst) => {
				return [`setIntroStoryPlaying(${params_lst[0]});`]
			}, ["Target State"]),
			new Code(0x2C, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					`FUN_80724B5C(${params_lst[1]&0xFF},${params_lst[2]&0xFF},0xDC,0xD8,afStack44);`,
					`int uvar1 = FUN_80665DE0(afStack44[0],uvar0->xPos,uvar0->zPos);`,
					"uvar0->rotation.x = uvar1;",
				]
			}, ["Spawner ID (>0) or Player (0)", "Param 1", "Param 2"]),
			new Code(0x2D, (params_lst) => {
				return [`FUN_8061CF80(${params_lst[0]});`]
			}, ["Param 1"]),
			new Code(0x2E, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					`uvar0->field_15E = ${params_lst[1] & 0xFF};`,
				]
			}, ["Spawner ID (>0) or Player (0)", "Actor->0x15E"]),
			new Code(0x2F, (params_lst) => {
				code = [`modifyObjectState(${params_lst[0]},${params_lst[3]}`]
				if (params_lst[1] != 0) {
					code.push(`modifyObjectState(${params_lst[1]},${params_lst[3]}`)
				}
				if (params_lst[2] != 0) {
					code.push(`modifyObjectState(${params_lst[2]},${params_lst[3]}`)
				}
				return code
			}, ["Object ID 1", "Object ID 2", "Object ID 3", "Target State"], "Modify Multiple Object Model 2 Instance States"),
			new Code(0x30, (params_lst) => {
				code = [`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`]
				if (params_lst[1] > 0x7FF) {
					return code.concat([
						"uvar0->obj_params_bitfield &= 0xFF7FFFFF;"
					])
				}
				return code.concat([
					`uvar0->red = ${params_lst[1] & 0xFF}`,
					`uvar0->green = ${params_lst[2] & 0xFF}`,
					`uvar0->blue = ${params_lst[3] & 0xFF}`,
					"uvar0->obj_params_bitfield |= 0x800000;",
				])
			}, ["Spawner ID (>0) or Player (0)", "Red", "Green", "Blue"], "Modify Actor RGB Mask"),
			new Code(0x31, (params_lst) => {
				if (params_lst[0] == 0) {
					return [
						`FUN_80721560(0x20,0x82,0,${params_lst[0]},${params_lst[1] & 0xFF},${params_lst[2] & 0xFF});`,
						"FUN_807215D0(1,0);",
					]
				}
				return [
					"FUN_80721560(0x20,0x82,0,100,100);",
					"FUN_807215D0(1,0);",
				]
			}, ["Param 4", "Param 5", "Param 6"]),
			new Code(0x32, (params_lst) => {
				return [
					`FUN_8065F49C(${params_lst[0]},${params_lst[1]},${params_lst[2]},${params_lst[3]} * DOUBLE_807580A8);` // Water something?
				]
			}, ["Param 1", "Param 2", "Param 3", "Param 4"]),
			new Code(0x33, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					"int* uvar1 = uvar0->field_17C",
					"uvar1->field_30 = 0xFE;",
					`uvar1->field_33 = ${params_lst[1]};`,
					`uvar1->field_22 = ${params_lst[2]};`,
					`uvar1->field_32 = ${params_lst[3]};`,
					"uvar1->field_31 = 1;",
				]
			}, ["Spawner ID (>0) or Player (0)", "Field 0x33", "Field 0x22", "Field 0x32"]),
			new Code(0x34, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					"uvar0->field_17C->field_30 = 0xFF;",
				]
			}, ["Spawner ID (>0) or Player (0)"]),
			new Code(0x35, (params_lst) => {
				if (params_lst[0] == 0) {
					return ["BananaMedalGet();"]
				}
				return []
			}, ["Enable"], "Get Banana Medal"),
			new Code(0x36, (params_lst) => {
				return [
					`tagKong(${params_lst[0]});`,
					"clearGun(Player);",
				]
			}, ["Kong Index"], "Tag Kong"),
			new Code(0x37, (params_lst) => {
				if (params_lst[0] == 0) {
					code = ["int* uvar0 = Player;"]
				} else {
					code = [`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`]
				}
				return code.concat([
					"FUN_80605314(uvar0,0);"
				])
			}, ["Spawner ID (>0) or Player (0)"]),
			new Code(0x38, (params_lst) => {
				if (params_lst[0] == 0) {
					code = ["int* uvar0 = Player;"]
				} else {
					code = [`int* uvar0 = getSpawnerTiedActor(${params_lst[0]},0);`]
				}
				return code.concat([`FUN_80604CBC(uvar0,${params_lst[1]},0,1);`])
			}, ["Spawner ID (>0) or Player (0)", "Param 2"]),
			new Code(0x39, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					`FUN_8070D8C0(uvar0,${params_lst[1]},${params_lst[2]})`,
				]
			}, ["Spawner ID (>0) or Player (0)", "Param 2", "Param 3"]),
			new Code(0x3A, (params_lst) => {
				return ["preventTransition();"]
			}, [], "Prevent Transition"),
			new Code(0x3B, (params_lst) => {
				return [
					`int* uvar0 = getActorFromSpawnerTriggerOrPlayerIfZero(${params_lst[0]});`,
					`uvar0->field_146 = ${params_lst[1]};`,
				]
			}, ["Spawner ID (>0) or Player (0)", "Field 0x146"]),
			new Code(0x3C, (params_lst) => {
				return [
					"int* uvar0 = getSpawnerTiedActor(1,0);",
					`uvar0->field_17C->field_D |= ${params_lst[0]};`,
				]
			}, ["Field 0xD"]),
			new Code(0x3D, (params_lst) => {
				return ["initMapChange(PreviousMap,0);"]
			}, [], "Warp to previous map"),
			new Code(0x3E, (params_lst) => {
				return ["initMapChange(0x22,0xC);"]
			}, [], "Warp to outside K. Rool's Ship"),
			new Code(0x3F, (params_lst) => {
				return [
					`handleEndSequence(${params_lst[0]},${params_lst[1]},${params_lst[2]});`
				]
			}, ["Param 1", "Param 2", "Param 3"], "Handle End Sequence"),
			new Code(0x40, (params_lst) => {
				return ["loadEndSequence(0);"]
			}, [], "Load End Sequence"),
			new Code(0x41, (params_lst) => {
				return ["exitMinigameOrBoss();"]
			}, [], "Exit Minigame/Boss"),
			new Code(0x42, (params_lst) => {
				if (params_lst[1] != 0) {
					return [`spawnKRoolText(${params_lst[0] & 0xFF},${params_lst[1]},${params_lst[2]});`]
				}
				return [`spawnKRoolText(${params_lst[0] & 0xFF},0x5A,${params_lst[2]});`]
			}, ["Param 1", "Param 2", "Param 3"], "Spawn K. Rool speech text (From level story intros)"),
			new Code(0x43, (params_lst) => {
				return [
					"if (isISGActive() == 0) {",
					`ExitWarp = ${params_lst[2] & 0xFF};`,
					`initTransitionWGamemode(${params_lst[0]},${params_lst[1]});`,
					"}",
				]
			}, ["Map", "Cutscene", "Exit"], "Initiate Transition with non-zero exit with ISG Check"),
			new Code(0x44, (params_lst) => {
				return [`FUN_80602488(${params_lst[0]});`]
			}, ["Param 1"]),
			new Code(0x45, (params_lst) => {
				return ["setSpawnerTiedActorControlState(2,40);"]
			}, [], "Delete Actor from Spawner ID"),
		]

		function parseSubCommand(command, params) {
			code = []
			codeBlocks.filter(item => item.index == command).forEach(item => {
				code = code.concat(item.output(params))
			})
			return code.join("\n")
		}

		function arrToInt(arr) {
			total = 0
			arr.forEach(item=> {
				total = (total * 256) + item
			})
			return total
		}

		function grabAddress(addr) {
			size = 4
			bytes = file_bytes.filter((item,index) => {
				if ((index >= addr) && (index < (addr + size))) {
					return true;
				}
				return false;
			})
			return arrToInt(bytes) + main_pointer_table_offset
		}

		function grab_bytes(start,finish) {
			return file_bytes.filter((item,index) => {
				if ((index >= start) && (index < finish)) {
					return true;
				}
				return false;
			})
		}

		function readData(bytes,size,start) {
			return arrToInt(bytes.filter((item,index) => {
				if ((index >= start) && (index < (start + size))) {
					return true
				}
				return false;
			}))
		}

		function readData_s16(bytes,start) {
			val = readData(bytes, 2, start)
			if (val > 0x7FFF) {
				return val - 65536
			}
			return val
		}

		function getByteSeries(bytes, size, start) {
			return bytes.filter((item, index) => (index >= start) && (index < (start + size)))
		}

		function getItemHeader(data, start, size) {
			return {
				"read": [...getByteSeries(data, size, start+4)],
				"head": [...getByteSeries(data, 2, start+2)]
			}
		}

		function parsePoint(point_json) {
			command = point_json["command"]
			switch (command) {
				case 10:
				case 15:
				case 16:
				case 17:
					point_json["code"] = ["LevelStateBitfield |= 0x2000;"]
					break;
				case 6:
					point_json["code"] = ["nextCutscenePart()"]
					break;
				case 11:
					point_json["code"] = ["cancel cutscene something"]
					break;
				case 12:
					point_json["code"] = [`playSong('${songs[point_json['song']]}');`]
					break;
				case 14:
					point_json["code"] = ["playCutsceneInMap();"]
					break;
				case 13:
					command_info = {
						"sub_command": readData(point_json["read"], 4, 0)
					}
					params = []
					param_count = parseInt((point_json["read"].length - 4) / 2)
					for (let a = 0; a < param_count; a++) {
						params.push(readData(point_json["read"], 2, 4 + (2 * a)))
					}
					command_info["params"] = params
					sub_command = command_info["sub_command"]
					code = parseSubCommand(sub_command,params)
					point_json["code"] = code
					point_json["detailed_command"] = command_info
					break;
				case 4:
				case 5:
					//point_json["code"] = point_json["code"].join("\n")
			}
		}

		var cutscene_data = [];
		function parseFile() {
			header_info = []
			base_info = []
			cutscene_info = []
			point_info = []
            data = file_bytes.slice()
            info_l = 0x30
            read_l = 0
			// Header stupidity
            for (let i = 0; i < 0x18; i++) {
                header_info_count = readData(data, 2, read_l)
                for (let j = 0; j < header_info_count; j++) {
                    info = {
                        "unk0": readData(data, 2, info_l)
                    }
                    header_info.push(info)
                    info_l += 0x12
                }
                read_l += 2
            }
            base_count = readData(data,2,info_l)
            info_l += 2
            for (let i = 0; i < base_count; i++) {
                info = {
                    "x": readData(data,2,info_l+0x10),
                    "y": readData(data,2,info_l+0x12),
                    "z": readData(data,2,info_l+0x14),
                }
                base_info.push(info)
                info_l += 0x1C
            }
			header_end = info_l
            cutscene_count = readData(data,2,info_l)
			// Cutscene Point Sequences
			info_l += 2
			for (let i = 0; i < cutscene_count; i++) {
				subcount = readData(data,2,info_l)
				info_l += 2
				point_sequence = []
				point_duration = []
				for (let j = 0; j < subcount; j++) {
					point_sequence.push(readData(data,2,info_l))
					point_duration.push(readData(data,2,info_l+2))
					info_l += 4
				}
				master = {
					"index": i,
					"count":subcount,
					"point_sequence": point_sequence,
					"point_durations": point_duration,
				}
				cutscene_info.push(master)
			}
			cutscene_point_count = readData(data,2,info_l)
			// Item Processing
			count_copy = cutscene_point_count
			info_l += 2
			repeat = 0
			unk0_list = []
			seg_idx = 0
			while (count_copy != 0) {
				command = readData(data,1,info_l+1)
				unk0_item = readData(data,1,info_l)
				if (!unk0_list.includes(unk0_item)) {
					unk0_list.push(unk0_item)
				}
				info = {
					"unk0": unk0_item,
					"command": command,
					"segment": seg_idx,
					"references": 0,
				}
				seg_idx += 1
				orig = count_copy
				count_copy -= 1
				switch (command) {
					case 1:
						info = {
							...info,
							...getItemHeader(data, info_l, 6)
						}
						info_l += 10
						break;
					case 2:
						info = {
							...info,
							...getItemHeader(data, info_l, 8)
						}
						info_l += 12
						break;
					case 3:
					case 13:
						info = {
							...info,
							...getItemHeader(data, info_l, 12)
						}
						info_l += 16
						break;
					case 4:
						// Cutscene Pan
						read_lst = []
						point_lst = []
						point_list_count = readData(data,2,info_l+4)
						info = {
							...info,
							...getItemHeader(data, info_l, 0x1C)
						}
						info_l += 0x4
						for (let j = 0; j < point_list_count + 2; j++) {
							read_lst = read_lst.concat([...getByteSeries(data, 0xE, info_l)])
							point_item = {
								"x": readData_s16(data,info_l),
								"y": readData_s16(data,info_l+2),
								"z": readData_s16(data,info_l+4),
								"rot":{
									"x":readData(data,2,info_l+6),
									"y":readData(data,2,info_l+8),
									"z":readData(data,2,info_l+10),
								},
								"zoom":readData(data,1,info_l+12),
								"roll":readData(data,1,info_l+13),
							}
							if (j == 0) {
								info["point_start"] = Object.assign({}, point_item)
							} else if (j == 1) {
								info["point_end"] = Object.assign({}, point_item)
							} else {
								point_lst.push(Object.assign({}, point_item))
							}
							info_l += 0xE
						}
						info["read"] = read_lst
						info["points"] = point_lst
						break;
					case 5:
						// Cutscene Pan 2
						read_lst = []
						point_lst = []
						point_list_count = readData(data,2,info_l+4)
						info = {
							...info,
							...getItemHeader(data, info_l, 0x10)
						}
						info_l += 0x4
						for (let j = 0; j < point_list_count + 2; j++) {
							read_lst = read_lst.concat([...getByteSeries(data, 8, info_l)])
							point_item = {
								"x": readData_s16(data,info_l),
								"y": readData_s16(data,info_l+2),
								"z": readData_s16(data,info_l+4),
								"zoom": readData(data,1,info_l+6),
								"roll": readData(data,1,info_l+7),
							}
							if (j == 0) {
								info["point_start"] = Object.assign({}, point_item)
							} else if (j == 1) {
								info["point_end"] = Object.assign({}, point_item)
							} else {
								point_lst.push(Object.assign({}, point_item))
							}
							info_l += 0x8
						}
						info["read"] = read_lst
						info["points"] = point_lst
						break;
					case 10:
					case 15:
					case 16:
						info = {
							...info,
							...getItemHeader(data, info_l, 14)
						}
						info_l += 18
						break;
					case 12:
						info = {
							...info,
							...getItemHeader(data, info_l, 2)
						}
						info["song"] = readData(data, 2, info_l + 4)
						info_l += 6
						break;
					default:
						info = {
							...info,
							...getItemHeader(data, info_l, 0)
						}
						count_copy += 1
						info_l += 4
						break;
				}				
				point_info.push(info)
			}
			point_info.forEach(point => {
				parsePoint(point);
			})
			cutscene_info.forEach(cutscene => {
				point_data = []
				for (let j = 0; j < cutscene["count"]; j++) {
					point = cutscene["point_sequence"][j]
					if (point_info[point]) {
						point_info[point]["references"] += 1
						let point_copy = {
							...point_info[point]
						}
						point_copy["duration"] = cutscene["point_durations"][j]
						point_data.push(point_copy)
					}
				}
				cutscene["point_data"] = point_data
			})
			cutscene_data = {
				"cutscenes": cutscene_info,
				"points": point_info,
				"header_data": getByteSeries(data, header_end, 0)
			}
			return cutscene_data 
		}
	</script>
</body>
</html>